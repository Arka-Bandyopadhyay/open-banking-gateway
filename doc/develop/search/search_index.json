{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Open Banking Gateway Provides tools, adapters and connectors for transparent access to open banking apis. The initial effort focuses on the connectivity to banks that implement the European PSD2 directive either through one of the common market initiatives like : The Berlin Group NextGenPSD2 The Open Banking UK The Polish PSD2 API Or even through proprietary bank api like the ING\u2019s PSD2 API What this Project is about Key Challenge for a TPPs PSD2 as the first regulatory driven Open Banking initiative offers many opportunities for both Banks and Third Party Providers. TPPs can use the account information and payment services provided by the banks in order to offer new innovative services to the end users. The more banks a TPP can interact with each other, the more end consumer can be provided with reacher banking solutions, which in turn simplifies and leverage commercial value chains. Being able to interact with different bank APIs can be a time and cost consuming challenge. Even though PSD2 sets a standard for bank interfaces, there is a lot of space for implementation options. A bank, therefore, can have it's own PSD2 compliant solution or implement one of the known market standards, like Open Banking UK, Berlin Group or STET. This open banking gateway will provide with a common interface with the aim of simplifying access to those APIs by third parties. Third Parties Contribution This project is designed to enable contribution from different sources, as the open banking challenge will start with a magnitude of discrepancies in individual bank implementations, even for banks implementing a common standards. The following picture displays the overall architecture of this banking gateway: Releases and versions Versioning, Release and Support policy Release notes Roadmap for next features development Initial Requirements Authors & Contact Francis Pouatcha - Initial work - adorsys See also the list of contributors who participated in this project. For commercial support please contact adorsys Team . License This project is licensed under the Apache License version 2.0 - see the LICENSE file for details Checkstyle The code uses backend.checkstyle.xml placed in the root of the project. To activate it with intellij install the CheckStyle-IDEA v5.34.0 Plugin and configure in Other Settings -> Checkstyle the version 8.19 and add the configuration file backend.checkstyle.xml . open api The code generated from opba-consent-rest-api/src/main/resources/static/consent_api.yml opba-banking-rest-api/src/main/resources/static/banking_api_ais.yml is generated to opba-consent-rest-api/target/generated-sources/open-api/src/main/java opba-banking-rest-api/target/generated-sources/open-api/src/main/java So the folders have to be made known to the ide. Dictionary Dictionary Contribution Guidelines Contribution Guidelines JavaDoc JavaDoc Use Cases Use Cases","title":"Home"},{"location":"#open-banking-gateway","text":"Provides tools, adapters and connectors for transparent access to open banking apis. The initial effort focuses on the connectivity to banks that implement the European PSD2 directive either through one of the common market initiatives like : The Berlin Group NextGenPSD2 The Open Banking UK The Polish PSD2 API Or even through proprietary bank api like the ING\u2019s PSD2 API","title":"Open Banking Gateway"},{"location":"#what-this-project-is-about","text":"","title":"What this Project is about"},{"location":"#key-challenge-for-a-tpps","text":"PSD2 as the first regulatory driven Open Banking initiative offers many opportunities for both Banks and Third Party Providers. TPPs can use the account information and payment services provided by the banks in order to offer new innovative services to the end users. The more banks a TPP can interact with each other, the more end consumer can be provided with reacher banking solutions, which in turn simplifies and leverage commercial value chains. Being able to interact with different bank APIs can be a time and cost consuming challenge. Even though PSD2 sets a standard for bank interfaces, there is a lot of space for implementation options. A bank, therefore, can have it's own PSD2 compliant solution or implement one of the known market standards, like Open Banking UK, Berlin Group or STET. This open banking gateway will provide with a common interface with the aim of simplifying access to those APIs by third parties.","title":"Key Challenge for a TPPs"},{"location":"#third-parties-contribution","text":"This project is designed to enable contribution from different sources, as the open banking challenge will start with a magnitude of discrepancies in individual bank implementations, even for banks implementing a common standards. The following picture displays the overall architecture of this banking gateway:","title":"Third Parties Contribution"},{"location":"#releases-and-versions","text":"Versioning, Release and Support policy Release notes Roadmap for next features development Initial Requirements","title":"Releases and versions"},{"location":"#authors-contact","text":"Francis Pouatcha - Initial work - adorsys See also the list of contributors who participated in this project. For commercial support please contact adorsys Team .","title":"Authors &amp; Contact"},{"location":"#license","text":"This project is licensed under the Apache License version 2.0 - see the LICENSE file for details","title":"License"},{"location":"#checkstyle","text":"The code uses backend.checkstyle.xml placed in the root of the project. To activate it with intellij install the CheckStyle-IDEA v5.34.0 Plugin and configure in Other Settings -> Checkstyle the version 8.19 and add the configuration file backend.checkstyle.xml .","title":"Checkstyle"},{"location":"#open-api","text":"The code generated from opba-consent-rest-api/src/main/resources/static/consent_api.yml opba-banking-rest-api/src/main/resources/static/banking_api_ais.yml is generated to opba-consent-rest-api/target/generated-sources/open-api/src/main/java opba-banking-rest-api/target/generated-sources/open-api/src/main/java So the folders have to be made known to the ide.","title":"open api"},{"location":"#dictionary","text":"Dictionary","title":"Dictionary"},{"location":"#contribution-guidelines","text":"Contribution Guidelines","title":"Contribution Guidelines"},{"location":"#javadoc","text":"JavaDoc","title":"JavaDoc"},{"location":"#use-cases","text":"Use Cases","title":"Use Cases"},{"location":"ContributionGuidelines/","text":"Development and contributing Internal development process Development is performed by 2-weeks sprints (We use kind of Scrum framework). We use Git flow for development. Leading branch is always develop . Each new feature/bugfix is done in its own branch. All features/bugs are documented in zenhub . After finishing branch and seeing that branch has successfully been build by travis a pull request to branch develop must be created in github . Each developer of the team with approval rights can have a look at pull request and do the review. If no review is done for more than 24 hours, the developer is allowed to merge the branch to develop branch. Of course build in travis must work after merge. The master branch is never touched. Never, except when release build is done. This is triggered by the project management. When release build is triggered the current develop is merged into master. For that master never ever must be updated manually. Definition of Ready The task is ready to be put into a sprint when all following conditions are met: * All dependencies are clear and the work to work with them are clarified * Use-case is defined in the task * Acceptance criteria are defined Definition of Done The Task could be accepted only when following requirements are met: * Code is reviewed (and approved) by another developer * API documentation in Swagger UI corresponds to acceptance criteria * At least one automated test for every Use-case exists nice to have Project documentation (Markdown files) contains the information how to run the demo of use case Javadocs for public methods are written (including parameter description). For REST interfaces Swagger-annotations are sufficient. Contributing Any person are free to join us by implementing some parts of code or fixing some bugs. For that separate branch has to be created. Technical conditions for the implementations Code styling If you are using Intellij IDEs, like we do, please consider importing our code-style settings. Further explanation in checkstyle Java Please use Optionals and corresponding streams instead of null-checks where possible We prefer using Mockito over EasyMock for unit-tests. We prefer SpringBoot autoconfiguration over manual Configuration where possible How to Release Release is being done using the release scripts ( (C) by Boris Skert ) located under scripts/release-scripts. For detailed info see README for release-scripts . Steps to make a release Release is made from local copy! Ensure that you have enough rights to push to master and develop branches $ git submodule update --init --remote $ scripts/release-scripts/release.sh <release-version> <next-develop-version> Example $ scripts/release-scripts/release.sh 1.0 1.1","title":"ContributionGuidelines"},{"location":"ContributionGuidelines/#development-and-contributing","text":"","title":"Development and contributing"},{"location":"ContributionGuidelines/#internal-development-process","text":"Development is performed by 2-weeks sprints (We use kind of Scrum framework). We use Git flow for development. Leading branch is always develop . Each new feature/bugfix is done in its own branch. All features/bugs are documented in zenhub . After finishing branch and seeing that branch has successfully been build by travis a pull request to branch develop must be created in github . Each developer of the team with approval rights can have a look at pull request and do the review. If no review is done for more than 24 hours, the developer is allowed to merge the branch to develop branch. Of course build in travis must work after merge. The master branch is never touched. Never, except when release build is done. This is triggered by the project management. When release build is triggered the current develop is merged into master. For that master never ever must be updated manually.","title":"Internal development process"},{"location":"ContributionGuidelines/#definition-of-ready","text":"The task is ready to be put into a sprint when all following conditions are met: * All dependencies are clear and the work to work with them are clarified * Use-case is defined in the task * Acceptance criteria are defined","title":"Definition of Ready"},{"location":"ContributionGuidelines/#definition-of-done","text":"The Task could be accepted only when following requirements are met: * Code is reviewed (and approved) by another developer * API documentation in Swagger UI corresponds to acceptance criteria * At least one automated test for every Use-case exists nice to have Project documentation (Markdown files) contains the information how to run the demo of use case Javadocs for public methods are written (including parameter description). For REST interfaces Swagger-annotations are sufficient.","title":"Definition of Done"},{"location":"ContributionGuidelines/#contributing","text":"Any person are free to join us by implementing some parts of code or fixing some bugs. For that separate branch has to be created.","title":"Contributing"},{"location":"ContributionGuidelines/#technical-conditions-for-the-implementations","text":"","title":"Technical conditions for the implementations"},{"location":"ContributionGuidelines/#code-styling","text":"If you are using Intellij IDEs, like we do, please consider importing our code-style settings. Further explanation in checkstyle","title":"Code styling"},{"location":"ContributionGuidelines/#java","text":"Please use Optionals and corresponding streams instead of null-checks where possible We prefer using Mockito over EasyMock for unit-tests. We prefer SpringBoot autoconfiguration over manual Configuration where possible","title":"Java"},{"location":"ContributionGuidelines/#how-to-release","text":"Release is being done using the release scripts ( (C) by Boris Skert ) located under scripts/release-scripts. For detailed info see README for release-scripts .","title":"How to Release"},{"location":"ContributionGuidelines/#steps-to-make-a-release","text":"Release is made from local copy! Ensure that you have enough rights to push to master and develop branches $ git submodule update --init --remote $ scripts/release-scripts/release.sh <release-version> <next-develop-version> Example $ scripts/release-scripts/release.sh 1.0 1.1","title":"Steps to make a release"},{"location":"initial_requirements/","text":"Initial Requirements Still in a draft state. We are working on the process of aligning documentation and code. Till that is done, we will be documenting using the gh-pages branch. What can you find here:","title":"Initial Requirements"},{"location":"initial_requirements/#initial-requirements","text":"Still in a draft state. We are working on the process of aligning documentation and code. Till that is done, we will be documenting using the gh-pages branch. What can you find here:","title":"Initial Requirements"},{"location":"releasenotes/","text":"Release Notes","title":"Release notes"},{"location":"releasenotes/#release-notes","text":"","title":"Release Notes"},{"location":"roadmap/","text":"Roadmap Our project starts on November 1st 2019 and the Banking Gateway team offers development with one branch: This project is planned until the end of 2020 and our current timetable (MVP1) is until April 2020, by which time the following targets should be achieved: * Demo Frontend used to test the Banking Gateway * Integration of german banks with Redirect and Embedded Approaches * TppBankSearchApi providing only German banks * TppBankingApi providing the following banking endpoints: * Get transaction information * Get list of reachable accounts * Get account details of a list of accessible accounts * Get balances for a given account and * Initiation of single payment","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"Our project starts on November 1st 2019 and the Banking Gateway team offers development with one branch: This project is planned until the end of 2020 and our current timetable (MVP1) is until April 2020, by which time the following targets should be achieved: * Demo Frontend used to test the Banking Gateway * Integration of german banks with Redirect and Embedded Approaches * TppBankSearchApi providing only German banks * TppBankingApi providing the following banking endpoints: * Get transaction information * Get list of reachable accounts * Get account details of a list of accessible accounts * Get balances for a given account and * Initiation of single payment","title":"Roadmap"},{"location":"version_policy/","text":"Version Policy","title":"Version Policy"},{"location":"version_policy/#version-policy","text":"","title":"Version Policy"},{"location":"architecture/1-loginWithFinTech/","text":"User Login Diagram Description Login-001, -002, -003 FinTechUI.loadFinTechApplication & enterLoginData FinTechUI displays the LoginUI to the PSU. PSU enters username and password and initiates the login request. Login-004, -005 FinTechApi.login The PSU initiate a session with the FinTech providing his username and password as known to the FinTechApi. Username and password are provided in a LoginRequest object. Upon successful login, the FinTechApi will return a response 200_UserProfile containing: * UserProfile: provided in the body. * sessionState: provided in the body. Used read the FinTechLoginSessionCookie. * FinTechLoginSessionCookie: provided in the Set-Cookie header. Login-006 FinTechUI.displayBankSearchScreen Upon successfull login, the FinTechUi displays the bank search screen to the PSU.","title":"Login with FinTech Application"},{"location":"architecture/1-loginWithFinTech/#user-login","text":"","title":"User Login"},{"location":"architecture/1-loginWithFinTech/#diagram","text":"","title":"Diagram"},{"location":"architecture/1-loginWithFinTech/#description","text":"","title":"Description"},{"location":"architecture/1-loginWithFinTech/#login-001-002-003-fintechuiloadfintechapplication-enterlogindata","text":"FinTechUI displays the LoginUI to the PSU. PSU enters username and password and initiates the login request.","title":"Login-001, -002, -003 FinTechUI.loadFinTechApplication &amp; enterLoginData"},{"location":"architecture/1-loginWithFinTech/#login-004-005-fintechapilogin","text":"The PSU initiate a session with the FinTech providing his username and password as known to the FinTechApi. Username and password are provided in a LoginRequest object. Upon successful login, the FinTechApi will return a response 200_UserProfile containing: * UserProfile: provided in the body. * sessionState: provided in the body. Used read the FinTechLoginSessionCookie. * FinTechLoginSessionCookie: provided in the Set-Cookie header.","title":"Login-004, -005 FinTechApi.login"},{"location":"architecture/1-loginWithFinTech/#login-006-fintechuidisplaybanksearchscreen","text":"Upon successfull login, the FinTechUi displays the bank search screen to the PSU.","title":"Login-006 FinTechUI.displayBankSearchScreen"},{"location":"architecture/2-searchBank/","text":"PSU Searches Bank By Keyword Definition Describes the bank search functionality in a FinTech Application. Generally bank search is provided to prevent PSU from manually entering complicated bank identifiers. This bank search API allows for incremental keyword based search. Implementation Approaches We will distinguish between remote and local incremental search. Remote Incremental Search The remote incremental search is implemented on the server side. A rest endpoint receives a keyword and return a list of matching search entries. Use Case Steps Use cases for this API: 1. PSU loads FinTechSearchScreen 2. FinTechUI displays a search screen to the PSU 3. PSU enters any keyword in the search input field 4. FinTechUI forward request to FinTechAPI 5. FinTechAPI forward request to TppBankSearchApi 6. TppBankSearchApi returns a list of matching BankDescriptors to FinTechAPI 7. FinTechAPI returns a list of matching BankDescriptors to FinTechBankSearchUI 8. UI displays list of found bank descriptors to PSU Step 4. through 8. is repeated as long as PSU modifies keywords (by adding or removing characters) RemoteSearch-001, -002 FinTechUI.loadFinTechSeachScreen, displaySearchScreen RemoteSearch-003 FinTechUI.enterSearchString RemoteSearch-004 FinTechApi.bankSearch The FinTechUI sends a get request to the FinTechApi. Request contains * keyword (searchInput): The bank search input string * start (searchStartIndex): The index of the first result * max (searchMaxResult): the max number of entries to return with the response. * sessionState: provided as a path param. Used to read the FinTechLoginSessionCookie. * FinTechLoginSessionCookie: provided in the Cookie header. Used to identify the PSU. RemoteSearch-005, -006 TppBankSearchApi.bankSearch The FinTechApi sends a get request to the TppBankSearchApi. Request contains * keyword (searchInput): The bank search input string * start (searchStartIndex): The index of the first result * max (searchMaxResult): the max number of entries to return with the response. TppBankSearchApi returns a search result with following information. * List : found entries. * searchInput: The bank search input string (might have been normalized in the backend). * searchStartIndex: The index of the first result * searchMaxResult: The max number of entries to return with the response. * searchTotalResult: The total count of entities found for the given search input. RemoteSearch-007 FinTechApi return 200_BankSearchResult Result returned to FinTechUI contains same information as in RemoteSearch-005 and addition session management information like: * sessionState: provided in the response body. Used read the FinTechLoginSessionCookie. * FinTechLoginSessionCookie: provided in the Set-Cookie header. RemoteSearch-007 FinTechUI.displaySearchResult Finally, the FinTechUI display's the bank search result to the PSU. Local Incremental Search Local incremental search generally provides a way of reducing round trip to servers. So there is no local incremental search endpoint, but an endpoint to download the list of all BankProfiles. The client is then responsible for the indexing and the implementation of the search logic. For the purpose of keeping the client code simple, interface will also provide the possibility of downloading a standard lucene index file, as many platform provide login provide processing of lucene indexes. This approach will prevent each client from perfoming the expensive lucene indexing. The following diagram describes additional steps performed in the local incremental search. Use Case Steps Use cases for this API: 1. PSU loads FinTechSearchScreen 2. FinTechUI requests the BankSearchIndex from FinTechApi 3. FinTechApi requests the BankSearchIndex from TppBankSearchApi 4. TppBankSearchApi return BankSearchIndex to FinTechApi 5. FinTechApi return BankSearchIndex to FinTechUI 6. FinTechUI displays a search screen to the PSU 7. PSU enters any keyword in the search input field 8. FinTechUI call the search routine of the embedded LocalSearch 9. LocalSearch uses the keyword to retrieve the list of matching entries 10. LocalSearch returns a list of matching BankDescriptors to FinTechBankSearchUI 11. UI displays list of found bank descriptors to PSU Step 8. through 11. is repeated as long as PSU modifies keywords (by adding or removing characters) Like this diagram shows, local bank search does not send request to the network. LocalSearch-001 FinTechUI.loadFinTechSeachScreen PSU loads the FinTechSearchString of the FinTechUI. LocalSearch-101, -103 FinTechApi.bankSearch The FinTechUI sends a get request to the FinTechApi. If the List is not yet loaded by the FinTechUI, the FinTechUI issues a bankSearch request to the FinTechApi. A keyword passed as query parameter allows the backend to reduce the initial extent of records included in the index. keyword (searchInput): The bank search input string. Must be used to reduce the extent of records to be included in the local search. E.g.: c=DE could limit the search to bank in Germany. start (searchStartIndex): The index of the first result. The start will be set to 0 to get all records. max (searchMaxResult): the max number of entries to return with the response. Set this number to -1 to receive all applicable records from the server. sessionState: provided as a path parameter. Used to read the FinTechLoginSessionCookie. FinTechLoginSessionCookie: provided in the Cookie header. Used to identify the PSU. TppBankSearchApi returns a search result with following information. * List : found entries. * searchInput: The bank search input string (might have been normalized in the backend). * searchStartIndex: The index of the first result * searchMaxResult: The max number of entries to return with the response. * searchTotalResult: The total count of entities found for the given search input. LocalSearch-102, -103 TppBankSearchApi.bankSearch The FinTechApi sends a get request to the TppBankSearchApi. Request contains * keyword (searchInput): The bank search input string * start (searchStartIndex): The index of the first result * max (searchMaxResult): the max number of entries to return with the response. TppBankSearchApi returns a search result with following information. * List : found entries. * searchInput: The bank search input string (might have been normalized in the backend). * searchStartIndex: The index of the first result * searchMaxResult: The max number of entries to return with the response. * searchTotalResult: The total count of entities found for the given search input. LocalSearch-104 FinTechApi return 200_BankSearchResult Result returned to FinTechUI contains same information as in LocalSearch-103 and addition session management information like: * sessionState: provided in the response body. Used read the FinTechLoginSessionCookie. * FinTechLoginSessionCookie: provided in the Set-Cookie header. LocalSearch-105 displaySearchScreen LocalSearch-106 .. 110 enterKeyword, LocalSearch.search As the PSU enters search keywords, the FinTechUI issues a search request to the LocalSearch that performs the search operation locally and returns corresponding result that is displayed to the PSU on the go. New Idioms Discriminator The searchInput object passed to FinTechApi in this case is called discriminator and is used to reduce the extent of records to be included in the local search. E.g.: c=DE could limit the search to bank in Germany. If for example the TPP does not support some banks, he can include that information in the searchInput-String. LocalSearch This is the UI-Komponent that operates (like lucene) on a local search index in the UI-Application. The technology used to implement this search is specific to the UI technology. JavaScript based technologies might use tools like: elasticlunr Caching List The List return for the purpose of a local search can be cached by the FinTechApi to reduce quantity of request issued to the TppBankSearchApi","title":"Search bank"},{"location":"architecture/2-searchBank/#psu-searches-bank-by-keyword","text":"","title":"PSU Searches Bank By Keyword"},{"location":"architecture/2-searchBank/#definition","text":"Describes the bank search functionality in a FinTech Application. Generally bank search is provided to prevent PSU from manually entering complicated bank identifiers. This bank search API allows for incremental keyword based search.","title":"Definition"},{"location":"architecture/2-searchBank/#implementation-approaches","text":"We will distinguish between remote and local incremental search.","title":"Implementation Approaches"},{"location":"architecture/2-searchBank/#remote-incremental-search","text":"The remote incremental search is implemented on the server side. A rest endpoint receives a keyword and return a list of matching search entries.","title":"Remote Incremental Search"},{"location":"architecture/2-searchBank/#use-case-steps","text":"Use cases for this API: 1. PSU loads FinTechSearchScreen 2. FinTechUI displays a search screen to the PSU 3. PSU enters any keyword in the search input field 4. FinTechUI forward request to FinTechAPI 5. FinTechAPI forward request to TppBankSearchApi 6. TppBankSearchApi returns a list of matching BankDescriptors to FinTechAPI 7. FinTechAPI returns a list of matching BankDescriptors to FinTechBankSearchUI 8. UI displays list of found bank descriptors to PSU Step 4. through 8. is repeated as long as PSU modifies keywords (by adding or removing characters)","title":"Use Case Steps"},{"location":"architecture/2-searchBank/#remotesearch-001-002-fintechuiloadfintechseachscreen-displaysearchscreen","text":"","title":"RemoteSearch-001, -002 FinTechUI.loadFinTechSeachScreen, displaySearchScreen"},{"location":"architecture/2-searchBank/#remotesearch-003-fintechuientersearchstring","text":"","title":"RemoteSearch-003 FinTechUI.enterSearchString"},{"location":"architecture/2-searchBank/#remotesearch-004-fintechapibanksearch","text":"The FinTechUI sends a get request to the FinTechApi. Request contains * keyword (searchInput): The bank search input string * start (searchStartIndex): The index of the first result * max (searchMaxResult): the max number of entries to return with the response. * sessionState: provided as a path param. Used to read the FinTechLoginSessionCookie. * FinTechLoginSessionCookie: provided in the Cookie header. Used to identify the PSU.","title":"RemoteSearch-004 FinTechApi.bankSearch"},{"location":"architecture/2-searchBank/#remotesearch-005-006-tppbanksearchapibanksearch","text":"The FinTechApi sends a get request to the TppBankSearchApi. Request contains * keyword (searchInput): The bank search input string * start (searchStartIndex): The index of the first result * max (searchMaxResult): the max number of entries to return with the response. TppBankSearchApi returns a search result with following information. * List : found entries. * searchInput: The bank search input string (might have been normalized in the backend). * searchStartIndex: The index of the first result * searchMaxResult: The max number of entries to return with the response. * searchTotalResult: The total count of entities found for the given search input.","title":"RemoteSearch-005, -006 TppBankSearchApi.bankSearch"},{"location":"architecture/2-searchBank/#remotesearch-007-fintechapi-return-200_banksearchresult","text":"Result returned to FinTechUI contains same information as in RemoteSearch-005 and addition session management information like: * sessionState: provided in the response body. Used read the FinTechLoginSessionCookie. * FinTechLoginSessionCookie: provided in the Set-Cookie header.","title":"RemoteSearch-007 FinTechApi return 200_BankSearchResult"},{"location":"architecture/2-searchBank/#remotesearch-007-fintechuidisplaysearchresult","text":"Finally, the FinTechUI display's the bank search result to the PSU.","title":"RemoteSearch-007 FinTechUI.displaySearchResult"},{"location":"architecture/2-searchBank/#local-incremental-search","text":"Local incremental search generally provides a way of reducing round trip to servers. So there is no local incremental search endpoint, but an endpoint to download the list of all BankProfiles. The client is then responsible for the indexing and the implementation of the search logic. For the purpose of keeping the client code simple, interface will also provide the possibility of downloading a standard lucene index file, as many platform provide login provide processing of lucene indexes. This approach will prevent each client from perfoming the expensive lucene indexing. The following diagram describes additional steps performed in the local incremental search.","title":"Local Incremental Search"},{"location":"architecture/2-searchBank/#use-case-steps_1","text":"Use cases for this API: 1. PSU loads FinTechSearchScreen 2. FinTechUI requests the BankSearchIndex from FinTechApi 3. FinTechApi requests the BankSearchIndex from TppBankSearchApi 4. TppBankSearchApi return BankSearchIndex to FinTechApi 5. FinTechApi return BankSearchIndex to FinTechUI 6. FinTechUI displays a search screen to the PSU 7. PSU enters any keyword in the search input field 8. FinTechUI call the search routine of the embedded LocalSearch 9. LocalSearch uses the keyword to retrieve the list of matching entries 10. LocalSearch returns a list of matching BankDescriptors to FinTechBankSearchUI 11. UI displays list of found bank descriptors to PSU Step 8. through 11. is repeated as long as PSU modifies keywords (by adding or removing characters) Like this diagram shows, local bank search does not send request to the network.","title":"Use Case Steps"},{"location":"architecture/2-searchBank/#localsearch-001-fintechuiloadfintechseachscreen","text":"PSU loads the FinTechSearchString of the FinTechUI.","title":"LocalSearch-001 FinTechUI.loadFinTechSeachScreen"},{"location":"architecture/2-searchBank/#localsearch-101-103-fintechapibanksearch","text":"The FinTechUI sends a get request to the FinTechApi. If the List is not yet loaded by the FinTechUI, the FinTechUI issues a bankSearch request to the FinTechApi. A keyword passed as query parameter allows the backend to reduce the initial extent of records included in the index. keyword (searchInput): The bank search input string. Must be used to reduce the extent of records to be included in the local search. E.g.: c=DE could limit the search to bank in Germany. start (searchStartIndex): The index of the first result. The start will be set to 0 to get all records. max (searchMaxResult): the max number of entries to return with the response. Set this number to -1 to receive all applicable records from the server. sessionState: provided as a path parameter. Used to read the FinTechLoginSessionCookie. FinTechLoginSessionCookie: provided in the Cookie header. Used to identify the PSU. TppBankSearchApi returns a search result with following information. * List : found entries. * searchInput: The bank search input string (might have been normalized in the backend). * searchStartIndex: The index of the first result * searchMaxResult: The max number of entries to return with the response. * searchTotalResult: The total count of entities found for the given search input.","title":"LocalSearch-101, -103 FinTechApi.bankSearch"},{"location":"architecture/2-searchBank/#localsearch-102-103-tppbanksearchapibanksearch","text":"The FinTechApi sends a get request to the TppBankSearchApi. Request contains * keyword (searchInput): The bank search input string * start (searchStartIndex): The index of the first result * max (searchMaxResult): the max number of entries to return with the response. TppBankSearchApi returns a search result with following information. * List : found entries. * searchInput: The bank search input string (might have been normalized in the backend). * searchStartIndex: The index of the first result * searchMaxResult: The max number of entries to return with the response. * searchTotalResult: The total count of entities found for the given search input.","title":"LocalSearch-102, -103 TppBankSearchApi.bankSearch"},{"location":"architecture/2-searchBank/#localsearch-104-fintechapi-return-200_banksearchresult","text":"Result returned to FinTechUI contains same information as in LocalSearch-103 and addition session management information like: * sessionState: provided in the response body. Used read the FinTechLoginSessionCookie. * FinTechLoginSessionCookie: provided in the Set-Cookie header.","title":"LocalSearch-104 FinTechApi return 200_BankSearchResult"},{"location":"architecture/2-searchBank/#localsearch-105-displaysearchscreen","text":"","title":"LocalSearch-105 displaySearchScreen"},{"location":"architecture/2-searchBank/#localsearch-106-110-enterkeyword-localsearchsearch","text":"As the PSU enters search keywords, the FinTechUI issues a search request to the LocalSearch that performs the search operation locally and returns corresponding result that is displayed to the PSU on the go.","title":"LocalSearch-106 .. 110 enterKeyword, LocalSearch.search"},{"location":"architecture/2-searchBank/#new-idioms","text":"","title":"New Idioms"},{"location":"architecture/2-searchBank/#discriminator","text":"The searchInput object passed to FinTechApi in this case is called discriminator and is used to reduce the extent of records to be included in the local search. E.g.: c=DE could limit the search to bank in Germany. If for example the TPP does not support some banks, he can include that information in the searchInput-String.","title":"Discriminator"},{"location":"architecture/2-searchBank/#localsearch","text":"This is the UI-Komponent that operates (like lucene) on a local search index in the UI-Application. The technology used to implement this search is specific to the UI technology. JavaScript based technologies might use tools like: elasticlunr","title":"LocalSearch"},{"location":"architecture/2-searchBank/#caching-list","text":"The List return for the purpose of a local search can be cached by the FinTechApi to reduce quantity of request issued to the TppBankSearchApi","title":"Caching List"},{"location":"architecture/3-selectBank/","text":"Select Bank General terms defined in the dictionary Definition The bank selection allows to download the BankProfile of a bank and cache it in the consent session for reuse while processing the PSU request. It can also be used to display bank details to the PSU at selection. Diagram Use Case Steps Use cases for this API: SelBnk-001 FinTechUI.selectBank PSU selects a bank from the list of banks displayed by the FinTechUI SelBnk-002 FinTechApi.loadBankProfile FinTechUI sends a load loadBankProfile request to FinTechAPI passing the bankId SelBnk-003 TppBankSearchApi.loadBankProfile FinTechAPI sends a load loadBankProfile request to TppBankSearchApi passing the bankId SelBnk-004 & 005 Return 200_BankProfile TppBankSearchApi returns the BankProfine object matching the given bankId. SelBnk-005 FinTechUI.displayBankProfile The displayed bank profile also displays banking api services offered by the selected bank.","title":"Select bank"},{"location":"architecture/3-selectBank/#select-bank","text":"General terms defined in the dictionary","title":"Select Bank"},{"location":"architecture/3-selectBank/#definition","text":"The bank selection allows to download the BankProfile of a bank and cache it in the consent session for reuse while processing the PSU request. It can also be used to display bank details to the PSU at selection.","title":"Definition"},{"location":"architecture/3-selectBank/#diagram","text":"","title":"Diagram"},{"location":"architecture/3-selectBank/#use-case-steps","text":"Use cases for this API:","title":"Use Case Steps"},{"location":"architecture/3-selectBank/#selbnk-001-fintechuiselectbank","text":"PSU selects a bank from the list of banks displayed by the FinTechUI","title":"SelBnk-001 FinTechUI.selectBank"},{"location":"architecture/3-selectBank/#selbnk-002-fintechapiloadbankprofile","text":"FinTechUI sends a load loadBankProfile request to FinTechAPI passing the bankId","title":"SelBnk-002 FinTechApi.loadBankProfile"},{"location":"architecture/3-selectBank/#selbnk-003-tppbanksearchapiloadbankprofile","text":"FinTechAPI sends a load loadBankProfile request to TppBankSearchApi passing the bankId","title":"SelBnk-003 TppBankSearchApi.loadBankProfile"},{"location":"architecture/3-selectBank/#selbnk-004-005-return-200_bankprofile","text":"TppBankSearchApi returns the BankProfine object matching the given bankId.","title":"SelBnk-004 &amp; 005 Return 200_BankProfile"},{"location":"architecture/3-selectBank/#selbnk-005-fintechuidisplaybankprofile","text":"The displayed bank profile also displays banking api services offered by the selected bank.","title":"SelBnk-005 FinTechUI.displayBankProfile"},{"location":"architecture/4-initiateAisConsent/","text":"List Of Transactions General terms defined in the dictionary Definition Request the list of transactions for a given bank account. Initiates a consent request if necessary. Generally the consent request is not explicitly initiated by the PSU. When the PSU requests for a banking service, if the FinTech has an existing consent that covers the service, no new consent will be initiated. Diagram Use Cases InitConsent-010 FinTechUI.displayBankServices The result of a bank selection is that the FinTechUI displays the BankProfile to the PSU. The bank profile also contains the list of services offered by the selected bank. InitConsent-020 : FinTechUI.selectService(listTransactions) The FinTechUI will forward the service selected to the FinTechApi. In this case listTransactions. The selection might be accompanied with some service specifications. For example in the case of listTransactions, this can be the iban of the target account. We will call this ListTransactionsSpec. InitConsent-030 : FinTechApi.listTransactions The FinTechUI issued a listTransactions request to the FinTechAPI with following information attached: FinTechLoginSessionCookie : Used to maintain session between PSU and FinTech. sessionState Used to read FinTechLoginSessionCookie. Passed as a path param. UserAgentContext Describes details associated with the user agent of the PSU. Generally not visible in the API as they are automatically provided by the user agent. The purpose is to transfer context specific information on the PsuUserAgent and the request that might later be required by the ASPSP like: * IP-Address, * IP-Port, * Accept, * Accept-Charset, * Accept-Encoding, * Accept-Language, * Device-ID, * User-Agent, * PSU-Geo-Location, * Http-Method. The bank-id Passed as a query parameter and referencing the given BankProfile contains meta information associated with the selected Bank. The account-id Sent as a query parameter and referencing the target bank account. The ListTransactionsSpec Specifies details of the service requested by the PSU. These are all query parameter associated with the request like: * dateFrom: Starting date (inclusive the date dateFrom) of the transaction list, mandated if no delta access is required. * dateTo: End date (inclusive the data dateTo) of the transaction list, default is \"now\" if not given. * deltaList: This data attribute is indicating that the AISP is in favor to get all transactions after the last report access for this PSU on the addressed account. * entryReferenceFrom: This data attribute is indicating that the AISP is in favor to get all transactions after the transaction with identification entryReferenceFrom alternatively to the above defined period. * bookingStatus: interested booking status. InitConsent-031 : FinTechApi.loadPsuConsentSession A PsuConsentSession is a reusable token, that can be used to request service with the TppBankingApi. It is a reference to the PSU in the world of the TPP. Whether a service request is covered by an existing PsuConsent is decided by the TppBankingApi. The Task of the FinTechApi is to load any existing PsuConsentSession and associate it with the PSU request to the TPP. InitConsent-040 : TppBankingApi.listTransactions Forward of the PSU request to TPP with following associated context informations: FinTechContext contains identification information associated with the FinTech. PsuConsentSession See InitConsent-031 UserAgentContext Same as in InitConsent-030 The account-id Same as in InitConsent-030 The bank-id Same as in InitConsent-030 ListTransactionsSpec Same as in InitConsent-030 InitConsent-041 TppBankingApi.loadBankingProtocol TppBankingApi selects the BankingProtocol based on the given BankProfile. InitConsent-050 : BankingProtocol.listTransactions The BankingProtocol associated with the given BankProfile decides on how to proceed with the request after loading and analyzing an eventually stored TppConsentSession. InitConsent-051 : BankingProtocol.loadTppConsentSession If there is existing consent associated with the PSU for the given service, the BankingProtocol will load the corresponding TppConsentSession . Information needed to load the TppConsentSession is contained in the given PsuConsentSession . Use the loaded TppConsentSession to retrieve an existing consent and proceed to the ASPSP with the service request. No Suitable Consent Present InitConsent-060 : Initiating a Consent with the ASPSP If there is no suitable consent available, the BankingProtocol will first proceed with a consent initiation request. This is, an initiated service request will either ends up in the expected service response or first redirect the PSU to the ConsentAuthorisationApi . Whether this operation is necessary or not depends on the AspspBankingApi interface. The selected banking protocol will know how to deal with this. UserAgentContext See UserAgentContext TppContext The Associated TppContext contains Tpp identifying information. AisConsent The AisConsent object contains information associated with the service request. InitConsent-061 : ConsentInit Response The response of the consent init request depends on the ASPSP implementation. It generally provides information needed to collect PSU identification information in the embedded case or information needed to redirect the PSU to the OnlineBankingApi . The result of a consent init session also carries an TppConsentSession , containing all information needed to be stored by the Tpp for the reference of the started consent session. InitConsent-062 : BankingProtocol calls RedirectSessionStoreApi for a redirectCode InitConsent-063 : RedirectSessionStoreApi The RedirectSessionStoreApi will encrypt and store the redirect session, indexing it with a redirectCode that can be used upon redirection by the ConsentAuthorisationApi to retrieve the corresponding TppConsentSession . InitConsent-063a : Encryption Encryption is performed to prevent unlawfull use of contained information in the Tpp's backend environment during the redirect session. InitConsent-063b : Storage an Expiration Encrypted TppConsentSession shall only be stored for the duration of the redirect session. InitConsent-063c : Auto Cleanup Auto Cleanup process will make sure all expired redirect sessions are removed from that storage. InitConsent-064 : RedirectSessionStoreApi returns redirectCode to BankingProtocol The redirectCode is a one time string that contains information used to retrieve redirectInfo from the TPP Server in a back channel. The redirectCode is short lived (like 10 seconds). This is, TPP server does not need to hold the record indexed by this redirectCode for more than the given expiration time. Record must also be deleted by the TPP on first retrieval by the ConsentAPI. InitConsent-065 : BankingProtocol reproduces PsuConsentSession from the TppConsentSession InitConsent-066 : Resulting Redirect Information is returned to the TppBankingApi The attached AspspRedirectInfo contains all information necessary to redirect the PSU to the ConsentAuthorisationApi . InitConsent-067 : TppBankingApi returns the PsuConsentSession an a redirectCode to FinTechApi InitConsent-068 : FinTechConsentSessionCookie Available in the request header. This cookie shall be set for the Max time given to the PSU for the authorization of the corresponding consent. The cookie can be bound to the end point FinTechApi.consentAuthDone so it does no need to be transported to the server on other requests. InitConsent-068a : finTechConsentSessionState Will be used to read and validate the corresponding FinTechConsentSessionCookie. InitConsent-069 : FinTechApi redirects userAgent to the ConsentAuthorisationApi PsuUserAgent redirection happens using a HTTP_302 redirectCode is attached as a query parameter produced FinTechLoginSessionCookie is returned as a cookie to the PsuUserAgent InitConsent-070 : Suitable Consent Present InitConsent-071 : Forward Service Request to ASPSP Service request is forwarded to the AspspBankingApi together with a reference to the consent. The Associated TppContext contains Tpp identifying information. InitConsent-072 : Returned Service Response if sent and displayed to the PSU.","title":"List of Transactions"},{"location":"architecture/4-initiateAisConsent/#list-of-transactions","text":"General terms defined in the dictionary","title":"List Of Transactions"},{"location":"architecture/4-initiateAisConsent/#definition","text":"Request the list of transactions for a given bank account. Initiates a consent request if necessary. Generally the consent request is not explicitly initiated by the PSU. When the PSU requests for a banking service, if the FinTech has an existing consent that covers the service, no new consent will be initiated.","title":"Definition"},{"location":"architecture/4-initiateAisConsent/#diagram","text":"","title":"Diagram"},{"location":"architecture/4-initiateAisConsent/#use-cases","text":"","title":"Use Cases"},{"location":"architecture/4-initiateAisConsent/#initconsent-010-fintechuidisplaybankservices","text":"The result of a bank selection is that the FinTechUI displays the BankProfile to the PSU. The bank profile also contains the list of services offered by the selected bank.","title":"InitConsent-010 FinTechUI.displayBankServices"},{"location":"architecture/4-initiateAisConsent/#initconsent-020-fintechuiselectservicelisttransactions","text":"The FinTechUI will forward the service selected to the FinTechApi. In this case listTransactions. The selection might be accompanied with some service specifications. For example in the case of listTransactions, this can be the iban of the target account. We will call this ListTransactionsSpec.","title":"InitConsent-020 : FinTechUI.selectService(listTransactions)"},{"location":"architecture/4-initiateAisConsent/#initconsent-030-fintechapilisttransactions","text":"The FinTechUI issued a listTransactions request to the FinTechAPI with following information attached:","title":"InitConsent-030 : FinTechApi.listTransactions"},{"location":"architecture/4-initiateAisConsent/#fintechloginsessioncookie","text":"Used to maintain session between PSU and FinTech.","title":"FinTechLoginSessionCookie:"},{"location":"architecture/4-initiateAisConsent/#sessionstate","text":"Used to read FinTechLoginSessionCookie. Passed as a path param.","title":"sessionState"},{"location":"architecture/4-initiateAisConsent/#useragentcontext","text":"Describes details associated with the user agent of the PSU. Generally not visible in the API as they are automatically provided by the user agent. The purpose is to transfer context specific information on the PsuUserAgent and the request that might later be required by the ASPSP like: * IP-Address, * IP-Port, * Accept, * Accept-Charset, * Accept-Encoding, * Accept-Language, * Device-ID, * User-Agent, * PSU-Geo-Location, * Http-Method.","title":"UserAgentContext"},{"location":"architecture/4-initiateAisConsent/#the-bank-id","text":"Passed as a query parameter and referencing the given BankProfile contains meta information associated with the selected Bank.","title":"The bank-id"},{"location":"architecture/4-initiateAisConsent/#the-account-id","text":"Sent as a query parameter and referencing the target bank account.","title":"The account-id"},{"location":"architecture/4-initiateAisConsent/#the-listtransactionsspec","text":"Specifies details of the service requested by the PSU. These are all query parameter associated with the request like: * dateFrom: Starting date (inclusive the date dateFrom) of the transaction list, mandated if no delta access is required. * dateTo: End date (inclusive the data dateTo) of the transaction list, default is \"now\" if not given. * deltaList: This data attribute is indicating that the AISP is in favor to get all transactions after the last report access for this PSU on the addressed account. * entryReferenceFrom: This data attribute is indicating that the AISP is in favor to get all transactions after the transaction with identification entryReferenceFrom alternatively to the above defined period. * bookingStatus: interested booking status.","title":"The ListTransactionsSpec"},{"location":"architecture/4-initiateAisConsent/#initconsent-031-fintechapiloadpsuconsentsession","text":"A PsuConsentSession is a reusable token, that can be used to request service with the TppBankingApi. It is a reference to the PSU in the world of the TPP. Whether a service request is covered by an existing PsuConsent is decided by the TppBankingApi. The Task of the FinTechApi is to load any existing PsuConsentSession and associate it with the PSU request to the TPP.","title":"InitConsent-031 : FinTechApi.loadPsuConsentSession"},{"location":"architecture/4-initiateAisConsent/#initconsent-040-tppbankingapilisttransactions","text":"Forward of the PSU request to TPP with following associated context informations:","title":"InitConsent-040 : TppBankingApi.listTransactions"},{"location":"architecture/4-initiateAisConsent/#fintechcontext","text":"contains identification information associated with the FinTech.","title":"FinTechContext"},{"location":"architecture/4-initiateAisConsent/#psuconsentsession","text":"See InitConsent-031","title":"PsuConsentSession"},{"location":"architecture/4-initiateAisConsent/#useragentcontext_1","text":"Same as in InitConsent-030","title":"UserAgentContext"},{"location":"architecture/4-initiateAisConsent/#the-account-id_1","text":"Same as in InitConsent-030","title":"The account-id"},{"location":"architecture/4-initiateAisConsent/#the-bank-id_1","text":"Same as in InitConsent-030","title":"The bank-id"},{"location":"architecture/4-initiateAisConsent/#listtransactionsspec","text":"Same as in InitConsent-030","title":"ListTransactionsSpec"},{"location":"architecture/4-initiateAisConsent/#initconsent-041-tppbankingapiloadbankingprotocol","text":"TppBankingApi selects the BankingProtocol based on the given BankProfile.","title":"InitConsent-041 TppBankingApi.loadBankingProtocol"},{"location":"architecture/4-initiateAisConsent/#initconsent-050-bankingprotocollisttransactions","text":"The BankingProtocol associated with the given BankProfile decides on how to proceed with the request after loading and analyzing an eventually stored TppConsentSession.","title":"InitConsent-050 : BankingProtocol.listTransactions"},{"location":"architecture/4-initiateAisConsent/#initconsent-051-bankingprotocolloadtppconsentsession","text":"If there is existing consent associated with the PSU for the given service, the BankingProtocol will load the corresponding TppConsentSession . Information needed to load the TppConsentSession is contained in the given PsuConsentSession . Use the loaded TppConsentSession to retrieve an existing consent and proceed to the ASPSP with the service request.","title":"InitConsent-051 : BankingProtocol.loadTppConsentSession"},{"location":"architecture/4-initiateAisConsent/#no-suitable-consent-present","text":"","title":"No Suitable Consent Present"},{"location":"architecture/4-initiateAisConsent/#initconsent-060-initiating-a-consent-with-the-aspsp","text":"If there is no suitable consent available, the BankingProtocol will first proceed with a consent initiation request. This is, an initiated service request will either ends up in the expected service response or first redirect the PSU to the ConsentAuthorisationApi . Whether this operation is necessary or not depends on the AspspBankingApi interface. The selected banking protocol will know how to deal with this.","title":"InitConsent-060 : Initiating a Consent with the ASPSP"},{"location":"architecture/4-initiateAisConsent/#useragentcontext_2","text":"See UserAgentContext","title":"UserAgentContext"},{"location":"architecture/4-initiateAisConsent/#tppcontext","text":"The Associated TppContext contains Tpp identifying information.","title":"TppContext"},{"location":"architecture/4-initiateAisConsent/#aisconsent","text":"The AisConsent object contains information associated with the service request.","title":"AisConsent"},{"location":"architecture/4-initiateAisConsent/#initconsent-061-consentinit-response","text":"The response of the consent init request depends on the ASPSP implementation. It generally provides information needed to collect PSU identification information in the embedded case or information needed to redirect the PSU to the OnlineBankingApi . The result of a consent init session also carries an TppConsentSession , containing all information needed to be stored by the Tpp for the reference of the started consent session.","title":"InitConsent-061 : ConsentInit Response"},{"location":"architecture/4-initiateAisConsent/#initconsent-062-bankingprotocol-calls-redirectsessionstoreapi-for-a-redirectcode","text":"","title":"InitConsent-062 : BankingProtocol calls RedirectSessionStoreApi for a redirectCode"},{"location":"architecture/4-initiateAisConsent/#initconsent-063-redirectsessionstoreapi","text":"The RedirectSessionStoreApi will encrypt and store the redirect session, indexing it with a redirectCode that can be used upon redirection by the ConsentAuthorisationApi to retrieve the corresponding TppConsentSession .","title":"InitConsent-063 : RedirectSessionStoreApi"},{"location":"architecture/4-initiateAisConsent/#initconsent-063a-encryption","text":"Encryption is performed to prevent unlawfull use of contained information in the Tpp's backend environment during the redirect session.","title":"InitConsent-063a : Encryption"},{"location":"architecture/4-initiateAisConsent/#initconsent-063b-storage-an-expiration","text":"Encrypted TppConsentSession shall only be stored for the duration of the redirect session.","title":"InitConsent-063b : Storage an Expiration"},{"location":"architecture/4-initiateAisConsent/#initconsent-063c-auto-cleanup","text":"Auto Cleanup process will make sure all expired redirect sessions are removed from that storage.","title":"InitConsent-063c : Auto Cleanup"},{"location":"architecture/4-initiateAisConsent/#initconsent-064-redirectsessionstoreapi-returns-redirectcode-to-bankingprotocol","text":"The redirectCode is a one time string that contains information used to retrieve redirectInfo from the TPP Server in a back channel. The redirectCode is short lived (like 10 seconds). This is, TPP server does not need to hold the record indexed by this redirectCode for more than the given expiration time. Record must also be deleted by the TPP on first retrieval by the ConsentAPI.","title":"InitConsent-064 : RedirectSessionStoreApi returns redirectCode to BankingProtocol"},{"location":"architecture/4-initiateAisConsent/#initconsent-065-bankingprotocol-reproduces-psuconsentsession-from-the-tppconsentsession","text":"","title":"InitConsent-065 : BankingProtocol reproduces PsuConsentSession from the TppConsentSession"},{"location":"architecture/4-initiateAisConsent/#initconsent-066-resulting-redirect-information-is-returned-to-the-tppbankingapi","text":"The attached AspspRedirectInfo contains all information necessary to redirect the PSU to the ConsentAuthorisationApi .","title":"InitConsent-066 : Resulting Redirect Information is returned to the TppBankingApi"},{"location":"architecture/4-initiateAisConsent/#initconsent-067-tppbankingapi-returns-the-psuconsentsession-an-a-redirectcode-to-fintechapi","text":"","title":"InitConsent-067 : TppBankingApi returns the PsuConsentSession an a redirectCode to FinTechApi"},{"location":"architecture/4-initiateAisConsent/#initconsent-068-fintechconsentsessioncookie","text":"Available in the request header. This cookie shall be set for the Max time given to the PSU for the authorization of the corresponding consent. The cookie can be bound to the end point FinTechApi.consentAuthDone so it does no need to be transported to the server on other requests.","title":"InitConsent-068 : FinTechConsentSessionCookie"},{"location":"architecture/4-initiateAisConsent/#initconsent-068a-fintechconsentsessionstate","text":"Will be used to read and validate the corresponding FinTechConsentSessionCookie.","title":"InitConsent-068a : finTechConsentSessionState"},{"location":"architecture/4-initiateAisConsent/#initconsent-069-fintechapi-redirects-useragent-to-the-consentauthorisationapi","text":"PsuUserAgent redirection happens using a HTTP_302 redirectCode is attached as a query parameter produced FinTechLoginSessionCookie is returned as a cookie to the PsuUserAgent","title":"InitConsent-069 : FinTechApi redirects userAgent to the ConsentAuthorisationApi"},{"location":"architecture/4-initiateAisConsent/#initconsent-070-suitable-consent-present","text":"","title":"InitConsent-070 : Suitable Consent Present"},{"location":"architecture/4-initiateAisConsent/#initconsent-071-forward-service-request-to-aspsp","text":"Service request is forwarded to the AspspBankingApi together with a reference to the consent. The Associated TppContext contains Tpp identifying information.","title":"InitConsent-071 : Forward Service Request to ASPSP"},{"location":"architecture/4-initiateAisConsent/#initconsent-072-returned-service-response-if-sent-and-displayed-to-the-psu","text":"","title":"InitConsent-072 : Returned Service Response if sent and displayed to the PSU."},{"location":"architecture/5-redirectPsuToConsentAPI/","text":"Redirect PSU to consent API Redirect-010 ConsentAuthorisationApi The redirect starts with a get request to ConsentAuthorisationApi.auth. The entryPoint of the ConsentAuthorisationApi, for processing a consent initiated on the TppBankingApi side. Diagram Request processing ConsentAuthorisationApi Redirect-021 Retrieve Corresponding BankingProtocol ConsentAuthorisationApi will use the given redirectCode to load the matching BankingProtocol. This means that the protocol selection information must be encoded in the redirectCode. See Issue #54 . 2.2 .. 2.6 Retrieve associated TppConsentSession ConsentAuthorisationApi will let BankingProtocol use the redirectCode to retrieve the TppConsentSession . Interacting with the PsuUserAgent 2.7 consentAuthState The CSRF-State String is called: consentAuthState 2.8 AuthorizeResponse The AuthorizeResponse returned to the ConsentAuthorisationUI is used to display info to the PSU. This AuthorizeResponse object is always synchronized with the ConsentAuthSessionCookie set with the same HTTP response object. Any session, account or payment information needed to manage the authorization process is stored in both AuthorizeResponse (for display) and in the encrypted in the ConsentAuthSessionCookie. The consentCookieString is httpOnly 2.9 ConsentAuthSessionCookie The ConsentAuthSessionCookie is used to maintain session between ConsentAuthorisationUI and ConsentAuthorisationApi. It will generated and set as a httpOnly, Secure 3. Displaying Consent Authorize UI 4. Redirecting PSU to the ASPSP The returned AuthorizeResponse object info information needed to redirect the PSU to the target ASPSP. BackRedirectURL (OKUrl, NOKURL, etc... dependent of ASPSP API) contains the consentAuthState.","title":"Redirect to Consent Authorization API"},{"location":"architecture/5-redirectPsuToConsentAPI/#redirect-psu-to-consent-api","text":"","title":"Redirect PSU to consent API"},{"location":"architecture/5-redirectPsuToConsentAPI/#redirect-010-consentauthorisationapi","text":"The redirect starts with a get request to ConsentAuthorisationApi.auth. The entryPoint of the ConsentAuthorisationApi, for processing a consent initiated on the TppBankingApi side.","title":"Redirect-010 ConsentAuthorisationApi"},{"location":"architecture/5-redirectPsuToConsentAPI/#diagram","text":"","title":"Diagram"},{"location":"architecture/5-redirectPsuToConsentAPI/#request-processing-consentauthorisationapi","text":"","title":"Request processing ConsentAuthorisationApi"},{"location":"architecture/5-redirectPsuToConsentAPI/#redirect-021-retrieve-corresponding-bankingprotocol","text":"ConsentAuthorisationApi will use the given redirectCode to load the matching BankingProtocol. This means that the protocol selection information must be encoded in the redirectCode. See Issue #54 .","title":"Redirect-021 Retrieve Corresponding BankingProtocol"},{"location":"architecture/5-redirectPsuToConsentAPI/#22-26-retrieve-associated-tppconsentsession","text":"ConsentAuthorisationApi will let BankingProtocol use the redirectCode to retrieve the TppConsentSession .","title":"2.2 .. 2.6 Retrieve associated TppConsentSession"},{"location":"architecture/5-redirectPsuToConsentAPI/#interacting-with-the-psuuseragent","text":"","title":"Interacting with the PsuUserAgent"},{"location":"architecture/5-redirectPsuToConsentAPI/#27-consentauthstate","text":"The CSRF-State String is called: consentAuthState","title":"2.7 consentAuthState"},{"location":"architecture/5-redirectPsuToConsentAPI/#28-authorizeresponse","text":"The AuthorizeResponse returned to the ConsentAuthorisationUI is used to display info to the PSU. This AuthorizeResponse object is always synchronized with the ConsentAuthSessionCookie set with the same HTTP response object. Any session, account or payment information needed to manage the authorization process is stored in both AuthorizeResponse (for display) and in the encrypted in the ConsentAuthSessionCookie. The consentCookieString is httpOnly","title":"2.8 AuthorizeResponse"},{"location":"architecture/5-redirectPsuToConsentAPI/#29-consentauthsessioncookie","text":"The ConsentAuthSessionCookie is used to maintain session between ConsentAuthorisationUI and ConsentAuthorisationApi. It will generated and set as a httpOnly, Secure","title":"2.9 ConsentAuthSessionCookie"},{"location":"architecture/5-redirectPsuToConsentAPI/#3-displaying-consent-authorize-ui","text":"","title":"3. Displaying Consent Authorize UI"},{"location":"architecture/5-redirectPsuToConsentAPI/#4-redirecting-psu-to-the-aspsp","text":"The returned AuthorizeResponse object info information needed to redirect the PSU to the target ASPSP. BackRedirectURL (OKUrl, NOKURL, etc... dependent of ASPSP API) contains the consentAuthState.","title":"4. Redirecting PSU to the ASPSP"},{"location":"architecture/5a-psuAuthEmbeddedConsent/","text":"Authorize Consent Embedded Approach Description Implements the process of collecting consent authorization credentials in an interface provided by the TPP as described EBA-RTS embedded approach. The authorization is designed as a recursive list of ChallengeResponse sessions. Diagram Use Cases AuthEmbedded-010 : Create ConsentAuthSessionCookie If the TppConsentSession has an authChallenge, the interaction starts with the initialization of a ConsentAuthSessionCookie . The ConsentAuthSessionCookie is encrypted with a key stored in the consentSessionState . AuthEmbedded-020 : Redirect to EmbeddedAuthInitScreen After preparation of the ConsentAuthSessionCookie, the UserAgent is redirected to the EmbeddedAuthInitScreen of the ConsentAuthorisationUI. AuthEmbedded-030-040 : Load AuthChallenges The generic endpoint at ConsentAuthorisationApi.embeddedAuth allows the ConsentAuthorisationUI to load AuthChallenges if any. The call returns the AuthorizeResponse that contains all information necessary to display returned challenges to the PSU. An ScaUIMetadaData object contain UI customization parameter. AuthEmbedded-050-060 : Display Auth Screen and Collect PSU Auth Data Using information contained in the AuthorizeResponse object, the ConsentAuthorisationUI will display the suitable AuthScreen to the PSU and use it to collect PsuAuthData. AuthEmbedded-070-087 : Send PsuAuthData to ConsentAuthorisationApi The generic endpoint at ConsentAuthorisationApi.embeddedAuth will finally be called again to send authentication data entered by the PSU to the BankingProtocol. AuthEmbedded-090-094 : Redirect to FinTechApi As the TppConsentSession presents no more AuthChallenge, a RedirectSession is prepared and the PSU is redirected back to the FinTechApi.","title":"Authorize Consent Embedded Approach"},{"location":"architecture/5a-psuAuthEmbeddedConsent/#authorize-consent-embedded-approach","text":"","title":"Authorize Consent Embedded Approach"},{"location":"architecture/5a-psuAuthEmbeddedConsent/#description","text":"Implements the process of collecting consent authorization credentials in an interface provided by the TPP as described EBA-RTS embedded approach. The authorization is designed as a recursive list of ChallengeResponse sessions.","title":"Description"},{"location":"architecture/5a-psuAuthEmbeddedConsent/#diagram","text":"","title":"Diagram"},{"location":"architecture/5a-psuAuthEmbeddedConsent/#use-cases","text":"","title":"Use Cases"},{"location":"architecture/5a-psuAuthEmbeddedConsent/#authembedded-010-create-consentauthsessioncookie","text":"If the TppConsentSession has an authChallenge, the interaction starts with the initialization of a ConsentAuthSessionCookie . The ConsentAuthSessionCookie is encrypted with a key stored in the consentSessionState .","title":"AuthEmbedded-010 : Create ConsentAuthSessionCookie"},{"location":"architecture/5a-psuAuthEmbeddedConsent/#authembedded-020-redirect-to-embeddedauthinitscreen","text":"After preparation of the ConsentAuthSessionCookie, the UserAgent is redirected to the EmbeddedAuthInitScreen of the ConsentAuthorisationUI.","title":"AuthEmbedded-020 : Redirect to EmbeddedAuthInitScreen"},{"location":"architecture/5a-psuAuthEmbeddedConsent/#authembedded-030-040-load-authchallenges","text":"The generic endpoint at ConsentAuthorisationApi.embeddedAuth allows the ConsentAuthorisationUI to load AuthChallenges if any. The call returns the AuthorizeResponse that contains all information necessary to display returned challenges to the PSU. An ScaUIMetadaData object contain UI customization parameter.","title":"AuthEmbedded-030-040 : Load AuthChallenges"},{"location":"architecture/5a-psuAuthEmbeddedConsent/#authembedded-050-060-display-auth-screen-and-collect-psu-auth-data","text":"Using information contained in the AuthorizeResponse object, the ConsentAuthorisationUI will display the suitable AuthScreen to the PSU and use it to collect PsuAuthData.","title":"AuthEmbedded-050-060 : Display Auth Screen and Collect PSU Auth Data"},{"location":"architecture/5a-psuAuthEmbeddedConsent/#authembedded-070-087-send-psuauthdata-to-consentauthorisationapi","text":"The generic endpoint at ConsentAuthorisationApi.embeddedAuth will finally be called again to send authentication data entered by the PSU to the BankingProtocol.","title":"AuthEmbedded-070-087 : Send PsuAuthData to ConsentAuthorisationApi"},{"location":"architecture/5a-psuAuthEmbeddedConsent/#authembedded-090-094-redirect-to-fintechapi","text":"As the TppConsentSession presents no more AuthChallenge, a RedirectSession is prepared and the PSU is redirected back to the FinTechApi.","title":"AuthEmbedded-090-094 : Redirect to FinTechApi"},{"location":"architecture/5b-psuAuthRedirectConsent/","text":"Authorize Consent Redirect Approach Description Describes the process of redirecting a PSU to the Online Banking interface of it's ASPSP. Diagram Use Cases AuthRedirect-010 & -020 : Display RedirectInfoPage ConsentAuthorisationUI.infoPanel page uses information provided by the AuthorizeResponse to display a redirect to ASPSP info page to the PSU. AuthRedirect-030 & -040 : Grant Redirect The PSU interface might decide to either allow the PSU to explicitly confirm or deny the redirection to the ASPSP, or automatically proceed with this without the consent of the PSU. In both case, the ConsentAuthorisationUI has to invoke the FinTechApi.toAspspGrant that will in turn invoke the ConsentAuthorisationApi.toAspspGrant endpoint to generate the redirect response. Managing Redirection AuthRedirect-050 : Redirecting PSU to the ASPSP Detailed specification of the redirect process might depend on the specification of the ASPSP interface. Nevertheless, the returned redirect link carries an ConsentAuthSessionCookie that is used to store consent details in the User Agent of the PSU. As well, the consentAuthState shall be part of any BackRedirectURL (OKUrl, nokUrl) so ConsentAuthorisationApi can read the ConsentAuthSessionCookie when ASPSP sends back PSU to the ConsentAuthorisationApi. AuthRedirect-060 : Back-Redirecting PSU to the ConsentAuthorisationAPI The endpoint ConsentAuthorisationAPI.fromAspspOk consumes a redirect call from the ASPSP Online Banking. The corresponding URL contains a consentAuthState. The consentAuthState will the be used to retrieve the attached ConsentAuthSessionCookie whose content will in turn be used to read the TppConsentSession. AuthRedirect-071 .. AuthRedirect-073 : Forward call to BankingProtocol The fromAspspOk method of the BankingProtocol is called with TppConsentSession and aspspAuthCode. - The aspspAuthCode can be use to retrieve Token from ASPSP Token endpoint in case of an oAuth Approach. - The consent session contains any other information needed to manage the consent process. AuthRedirect-077 Redirect PSU to FinTechAPI The TppConsentSession is temporarily encrypted and stored in the form of a RedirectSession. Corresponding redirectCode is used to redirect PSU to the FinTechAPI redirect endpoint. ConsentAuthSessionCookie is deleted with start of this back redirect process.","title":"Authorize Consent Redirect Approach"},{"location":"architecture/5b-psuAuthRedirectConsent/#authorize-consent-redirect-approach","text":"","title":"Authorize Consent Redirect Approach"},{"location":"architecture/5b-psuAuthRedirectConsent/#description","text":"Describes the process of redirecting a PSU to the Online Banking interface of it's ASPSP.","title":"Description"},{"location":"architecture/5b-psuAuthRedirectConsent/#diagram","text":"","title":"Diagram"},{"location":"architecture/5b-psuAuthRedirectConsent/#use-cases","text":"","title":"Use Cases"},{"location":"architecture/5b-psuAuthRedirectConsent/#authredirect-010-020-display-redirectinfopage","text":"ConsentAuthorisationUI.infoPanel page uses information provided by the AuthorizeResponse to display a redirect to ASPSP info page to the PSU.","title":"AuthRedirect-010 &amp; -020 : Display RedirectInfoPage"},{"location":"architecture/5b-psuAuthRedirectConsent/#authredirect-030-040-grant-redirect","text":"The PSU interface might decide to either allow the PSU to explicitly confirm or deny the redirection to the ASPSP, or automatically proceed with this without the consent of the PSU. In both case, the ConsentAuthorisationUI has to invoke the FinTechApi.toAspspGrant that will in turn invoke the ConsentAuthorisationApi.toAspspGrant endpoint to generate the redirect response.","title":"AuthRedirect-030 &amp; -040 : Grant Redirect"},{"location":"architecture/5b-psuAuthRedirectConsent/#managing-redirection","text":"","title":"Managing Redirection"},{"location":"architecture/5b-psuAuthRedirectConsent/#authredirect-050-redirecting-psu-to-the-aspsp","text":"Detailed specification of the redirect process might depend on the specification of the ASPSP interface. Nevertheless, the returned redirect link carries an ConsentAuthSessionCookie that is used to store consent details in the User Agent of the PSU. As well, the consentAuthState shall be part of any BackRedirectURL (OKUrl, nokUrl) so ConsentAuthorisationApi can read the ConsentAuthSessionCookie when ASPSP sends back PSU to the ConsentAuthorisationApi.","title":"AuthRedirect-050 : Redirecting PSU to the ASPSP"},{"location":"architecture/5b-psuAuthRedirectConsent/#authredirect-060-back-redirecting-psu-to-the-consentauthorisationapi","text":"The endpoint ConsentAuthorisationAPI.fromAspspOk consumes a redirect call from the ASPSP Online Banking. The corresponding URL contains a consentAuthState. The consentAuthState will the be used to retrieve the attached ConsentAuthSessionCookie whose content will in turn be used to read the TppConsentSession.","title":"AuthRedirect-060 : Back-Redirecting PSU to the ConsentAuthorisationAPI"},{"location":"architecture/5b-psuAuthRedirectConsent/#authredirect-071-authredirect-073-forward-call-to-bankingprotocol","text":"The fromAspspOk method of the BankingProtocol is called with TppConsentSession and aspspAuthCode. - The aspspAuthCode can be use to retrieve Token from ASPSP Token endpoint in case of an oAuth Approach. - The consent session contains any other information needed to manage the consent process.","title":"AuthRedirect-071 .. AuthRedirect-073 : Forward call to BankingProtocol"},{"location":"architecture/5b-psuAuthRedirectConsent/#authredirect-077-redirect-psu-to-fintechapi","text":"The TppConsentSession is temporarily encrypted and stored in the form of a RedirectSession. Corresponding redirectCode is used to redirect PSU to the FinTechAPI redirect endpoint. ConsentAuthSessionCookie is deleted with start of this back redirect process.","title":"AuthRedirect-077 Redirect PSU to FinTechAPI"},{"location":"architecture/6-consume_api/","text":"Consume API after Consent Authorization Description This workflow starts with the redirect link leaving from either Authorize Consent Redirect Approach or Authorize Consent Embedded Approach . This redirect link will be used by the FinTechApi to retrieve a corresponding Token that can be used to request services on behalf of the PSU. As long as this token is valid, token will be used to perform corresponding service request on behalf on the PSU. Diagram Use Cases BankingService-010 : FinTechApi.fromConsentOk The redirect request coming from the ConsentAuthorisationApi contains a redirectCode. This request will be forwarded by the FinTechApi to the TppBankingApi. The request contains following information: redirectCode Available in the redirect url. This information will be used to retrieve the authorization token from the TppBankingApi. So the information needs not be processed by the FinTechApi FinTechConsentSessionCookie Available in the request header. This cookie shall be set for the Max time given to the PSU for the authorization of the corresponding consent. The cookie can be bound to the end point FinTechApi.fromConsentOk so it does not need to be transported to the server on other requests. finTechConsentSessionState Available in the redirect url. Will be used to read and validate the corresponding FinTechConsentSessionCookie. BankingService-020 : Validate the redirectLink The finTechConsentSessionState will be used to read and validate the corresponding FinTechConsentSessionCookie. BankingService-030 : TppBankingApi.code2Token This end point is invoked by the FinTechApi to retrieve token used to send subsequent service requests to the TppBankingApi. We call this token PsuConsentSession. BankingService-040 : BankingProtocol.code2Token Forward request to banking protocol. BankingService-050 : storePsuConsent The returned PsuConsentSession is stored by the FinTechApi for future use. BankingService-060 .. BankingService-067 Service Requests The returned token is used to invoke the service request (ListTransactions). Service result is returned to the FinTechApi and displayed to the PSU.","title":"Consume Service"},{"location":"architecture/6-consume_api/#consume-api-after-consent-authorization","text":"","title":"Consume API after Consent Authorization"},{"location":"architecture/6-consume_api/#description","text":"This workflow starts with the redirect link leaving from either Authorize Consent Redirect Approach or Authorize Consent Embedded Approach . This redirect link will be used by the FinTechApi to retrieve a corresponding Token that can be used to request services on behalf of the PSU. As long as this token is valid, token will be used to perform corresponding service request on behalf on the PSU.","title":"Description"},{"location":"architecture/6-consume_api/#diagram","text":"","title":"Diagram"},{"location":"architecture/6-consume_api/#use-cases","text":"","title":"Use Cases"},{"location":"architecture/6-consume_api/#bankingservice-010-fintechapifromconsentok","text":"The redirect request coming from the ConsentAuthorisationApi contains a redirectCode. This request will be forwarded by the FinTechApi to the TppBankingApi. The request contains following information:","title":"BankingService-010 : FinTechApi.fromConsentOk"},{"location":"architecture/6-consume_api/#redirectcode","text":"Available in the redirect url. This information will be used to retrieve the authorization token from the TppBankingApi. So the information needs not be processed by the FinTechApi","title":"redirectCode"},{"location":"architecture/6-consume_api/#fintechconsentsessioncookie","text":"Available in the request header. This cookie shall be set for the Max time given to the PSU for the authorization of the corresponding consent. The cookie can be bound to the end point FinTechApi.fromConsentOk so it does not need to be transported to the server on other requests.","title":"FinTechConsentSessionCookie"},{"location":"architecture/6-consume_api/#fintechconsentsessionstate","text":"Available in the redirect url. Will be used to read and validate the corresponding FinTechConsentSessionCookie.","title":"finTechConsentSessionState"},{"location":"architecture/6-consume_api/#bankingservice-020-validate-the-redirectlink","text":"The finTechConsentSessionState will be used to read and validate the corresponding FinTechConsentSessionCookie.","title":"BankingService-020 : Validate the redirectLink"},{"location":"architecture/6-consume_api/#bankingservice-030-tppbankingapicode2token","text":"This end point is invoked by the FinTechApi to retrieve token used to send subsequent service requests to the TppBankingApi. We call this token PsuConsentSession.","title":"BankingService-030 : TppBankingApi.code2Token"},{"location":"architecture/6-consume_api/#bankingservice-040-bankingprotocolcode2token","text":"Forward request to banking protocol.","title":"BankingService-040 : BankingProtocol.code2Token"},{"location":"architecture/6-consume_api/#bankingservice-050-storepsuconsent","text":"The returned PsuConsentSession is stored by the FinTechApi for future use.","title":"BankingService-050 : storePsuConsent"},{"location":"architecture/6-consume_api/#bankingservice-060-bankingservice-067-service-requests","text":"The returned token is used to invoke the service request (ListTransactions). Service result is returned to the FinTechApi and displayed to the PSU.","title":"BankingService-060 .. BankingService-067 Service Requests"},{"location":"architecture/dictionary/","text":"Dictionary AisConsentSpec App AspspBankingApi BankDescriptor BankingProtocol BankProfile Center Center ConsentAuthorisationApi ConsentAuthorisationUI ConsentAuthSessionCookie consentAuthState ConsentData Considerations Dictionary Fintech2TppRedirectInfoPage FinTechApi FinTechContext FinTechDC FinTechLoginSessionCookie FinTechLoginSessionState FinTechUI Information OnlineBanking2ConsentAuthRedirectInfoPage OnlineBankingApi OnlineBankingConsentSessionCookie OnlineBankingLoginSessionCookie OnlineBankingUI PSU PsuConsentSession PsuIdentifier PsuUserAgent PsuUserDevice Redirection RedirectSessionStoreApi RedirectSession Sharing TppBankingApi TppBankSearchApi TppConsentSession TppContext TPP UserAgentContext WebBrowser PSU (Payment Service User) A Payment Service User is any natural person that make uses a payment service on behalf of himself or on behalf of a legal person. Properties of a PSU A PSU is a natural person A PSU is in possession of some personal non sharable online banking credentials A PSU uses applications running on some devices to interact with online services Identities of a PSU In the context of OpenBanking, a PSU might be interacting with up to three different legal entities to consume a single service. In the service chain, we will generally a FinTech , a TPP and the ASPSP . The OpenBanking contract establishes a relationship between the the PSU , the TPP and the ASPSP . This contract is mapped in the following sentence: \" PSU consents to the ASPSP to service requests from a designated TPP on his behalf\". Market practice shows that special independent TPPs will be setup to service multiple FinTechs (Agents). This still does not change the OpenBanking contract, extends the contract to the following sentence:\" PSU also consents to the TPP to service requests from a designated FinTech on his behalf. At the end, we have the following service chain: PSU -> FinTech -> TPP -> ASPSP that might also require following interactions (PSU -> FinTech), (PSU -> TPP), (PSU -> ASPSP), resulting in the PSU having to maintain up to 3 different identities. psu-id@fintech This is the identity of the PSU in the realm of the FinTech, as most FinTech application require the PSU to establish an identity before using the application. This is the most important identity as it covers the consumption of the core services. Further identities (tpp, aspsp) are only needed for authorization. This framework is designed such as to request the FinTech to provide a permanent unique identity of each PSU to the TPP. This is what we call the psu-id@fintech psu-id@tpp This is the PSU as known to the TPP. If TPP environment is designed to service a single FinTech, this identity can be set equal to the psu-id@fintech . If a TPPenvironment services multiple FinTech entities, the TPP will have to establish a separated PSU identity that references all corresponding FinTech identities. This requirement only exists because some OpenBanking specifications do not allow TPP to maintain multiple valid consents of the same type on the same bank account. In a situation where the TPP uses the same account information consent to service many FinTech, a TPP consent management layer must allow a PSU to revoke that consent for a designated FinTech without revoking the consent at the ASPSP level. psu-id@aspsp This is the identity of the PSU as known to the ASPSP. This identity generally matches an online banking identifier in the realm of the ASPSP. PsuUserDevice A PsuUserDevice runs applications used by the PSU to access banking functionality. Those applications are generally called PsuUserAgents. PsuUserAgent A PsuUserAgent is an application running on a user device and used by the PSU to access banking functionality. PsuUserAgents are either Web application running on a standard web browser or native applications. We distinguish among two types of PsuUserAgents. WebBrowser based UserAgent A WebBrowser is considered compliant in the context of this framework when it can protect specific information used between the PsuUserDevice and the the corresponding server application to track the user session. For session tracking, this framework uses Cookies RFC6265 . Native Applications The UserAgent might be a native application running on a user mobile device or a desktop computer. In this case, redirection might still take place, but with consideration of the physical transition between source and target UI-Application. Following specifications deal with security threads associated with the redirection between UI-Application on a user device: RFC8252:OAuth 2.0 for Native Apps , RFC7636:Proof Key for Code Exchange by OAuth Public Clients . For the purpose of keeping the overall architecture of this framework simple, we require native applications to provide the same behavior as the Web Browser based user agents described above. UserAgentContext Independent on the type of user agent, OpenBanking interfaces will require a class of information associated with the PsuUserAgent so they can perform verification of the authenticity of the original PSU request and customize the response produced for intermediary layers. We group these Data under the name \"UserAgentContext\" and they and they are among other: IP-Address, IP-Port, Accept, Accept-Charset, Accept-Encoding, Accept-Language, Device-ID, User-Agent, Geo-Location, Http-Method. Security Considerations Cookies The use of cookies provides the most elaborated way to protect a session established between a user agent and server application. We assume a user agent storing a cookie fulfills following requirements: - The user agent store cookies on the user device in the context of a user session. Means if two users are sharing the same user device, cookies stored by those users wont be mixed up with each order. - Cookies carrying the attribute HttpOnly are not provided access to scripts run by the browser based UserAgent. This requirement can not be enforced for mobile application. For that reason, mobile application will be passed under thorough security review before released for public use. - Cookies carrying the attribute Secure are only sent to the server over SSL connections. - Expired Cookies (attribute Expires ) are not sent to the server. - Cookies shall never be transmitted to a domain not matching it origin - In the same domain, cookies shall only be transmitted to the configured path. Redirection The server can request the user agent to redirect the user to another application by returning a 302 response code to the user agent. Redirection can generally happen in the same user agent environment (process) or can open a another user agent depending on the URL policy configured on the user device. For example depending on the protocol of the location URL, a redirection from a WebBrowser might open a NativeApp or vice versa. For this reason, any information to be carried by the redirection has to be part of the location URL. We will be using redirection to switch the user context from one application to another one. Following redirection will generally be found in this framework: - FinTechApi to-> ConsentAuthorisationApi - ConsentAuthorisationApi to-> OnlineBankingApi - OnlineBankingApi backTo-> ConsentAuthorisationApi - ConsentAuthorisationApi backTo-> FinTechApi Redirection and Data Sharing We assume all three applications FinTechApi, ConsentAuthorisationApi, OnlineBankingApi are hosted on different domains. This is, we are not expecting cookies set by one application to be visible to another application (this might still happen on some local development environment, where everything runs on localhost). We also do not advice adding persistent information to Location URL ( RedirectUrl ), as these are logged in files everywhere on infrastructure components in data centers. If we have any bulky information to share between the source application and the target application, we can add a OneTime and ShortLived authorization code we call redirectCode to RedirectUrl . This redirectCode can be used to retrieved shared payload through an authenticated back channel connection. This is the practice borrowed from oAuth2 RFC6749 . If we want to make sure the user is redirected back to the original user device, we can set a RedirectCookie while returning 302 to the source user agent. In this case, the url used by the target user agent to redirect the user back to the source user agent must: carry a path information (e.g. /consent/{auth-id}) that allows retransmission of the redirectCookie to the source, and carry a redirectState (e.g. /consent/{auth-id}/fromAspsp/{redirectState}) that can be used as XSRF token for the validation of the redirect cookie. SessionCookie and XSRF We assume all three applications FinTeApi, ConsentAuthorisationApi, OnlineBakingApi maintain their own session information with corresponding UIs. We assume those APIs use cookies to maintain session with the corresponding user agents. In the context of this framework, those cookies are called SessionCookies. We also expect a following behavior from APIs and UserAgents: A response that sets a SessionCookie also carries a corresponding X-XSRF-TOKEN in the response header. A request that authenticates with a session cookie must also add the X-XSRF-TOKEN to the request header. PsuConsentSession Once a consent authorization process is initiated by the TppBankingApi (Over the FinTechApi), we want to make sure that the PSU giving his consent (psu-id@tpp, psu-id@aspsp), is the same as the PSU requesting the service on the FinTechApi interface (psu-id@fintech). Ensuring the equivalence of those identities can be represented as (assuming alice and bob are PSU): alice@fintech ==> alice@tpp ==> alice@aspsp // Where alice@fintech ==> alice@tpp neans The person identified at the FinTechApi as alice@fintech // owns the necessary credentials used to identify at the ConsentAuthorisationApi as alice@tpp This is the most challenging task to be solved by this framework. This is, the integrity of the OpenBanking solution is broken when security breaches can be used to compromise equivalences like: bob@fintech ==> alice@tpp ==> alice@aspsp // although in reality bob@fintech =/=> alice@tpp In this case bob identifies with the FinTechApi (as bob@fintech) but manipulates alice to identify with the ConsentAuthorisationApi and provide her consent for the requested banking service. bob@fintech ==> bob@tpp ==> alice@aspsp // although in reality bob@tpp =/=> alice@aspsp In this case bob identifies with the FinTechApi and the ConsentAuthorisationApi but manipulates alice to identify with the OnlieBankingApi and provide her consent for the requested banking service. The biggest challenge we will be facing is to make sure: - In case of an SCA redirect/oauth/decoupled, the natural person (online banking account) that provides a consent at the OnlineBankingApi of the ASPSP (alice@aspsp) is also the one that initiated the underlying banking service at the FinTech (alice@fintech). Whereby \" is also the one \" is equivalent to \" owns the necessary credentials \". - In case of an SCA embedded, the natural person (online banking account) that provides her consent at the TTP ConsentAuthorisationApi (alice@tpp) is also the one that initiated the underlying banking service at the FinTechApi interface (alice@fintech). Whereby \" is also the one \" is equivalent to \" owns the necessary credentials \". Step-1: Identify PSU at the FinTechApi We always expect the PSU to be identified at the FinTechApi interface. So we assume that the psu-id@fintech is known. The integrity of the rest of the framework relys on the capability of the FinTech to protect the session associating the PSU to the FinTechApi. The service request itself is always initiated by the FinTechApi. Before initiation, we assume that the PSU (alice) has signed into the FinTechApi and her identity is known to the FinTechApi and thus associated with the service request forwarded to the TppBankingApi. Step-2: Store psu-id@fintech with the ConsentAuthorizationSession While processing a service request, if the TppBankingApi notices that the service request is not covered by a consent (either as a result of pre-checking the consent or from an error returned by the OpenBankingApi), the TppBankingApi will trigger a new ConsentAuthorizationSession. Starting a new ConsentAuthorizationSession, we require the TppBankingApi to store the identity of service requesting PSU alice@fintech with the ConsentAuthorizationSession record before initiating a redirect to the ConsentAuthorisationApi. This is, the ConsentAuthorizationSession record stored in the TPP Database will have the form [auth-id,redirectCode]=ConsentAuthorizationSession[auth-id,redirectCode, alice@fintech, ConsentData] // Where redirectCode is a one time key. // Where auth-id is the identifier of this ConsentAuthorizationSession where the redirectCode can be used by the ConsentAuthorisationApi once to retrieve the ConsentAuthorizationSession. Step-2: Identify PSU at the TPP ConsentAuthorisationApi At first, redirecting a PSU from the FinTechApi to the TPP ConsentAuthorisationApi does not establish any relationship between the PSU and the TPP, even if we can use the redirectCode associated with the redirected url to retrieve ConsentAuthorisationSession. Off course the ConsentAuthorisationApi knows that the ConsentAuthorizationSession was initiated by alice@fintech, but this does not mean that the PSU controlling the current UserAgent (known as ConsentAuthorisationUI) is the same natural person as alice@fintech. In order to proceed with the ConsentAuthorisationSession, the TPP ConsentAuthorisationApi will have to establish an identification of the natural person controlling the UserAgent(implicit or explicit), resulting in a new PSU identity called (psu-id@tpp). This PSU identity (psu-id@tpp) will also be associated with the ConsentAuthorisationSession. At this stage, the ConsentAuthorizationSession record stored in the TPP Database will have the form: [auth-id,redirectCode]=ConsentAuthorizationSession[auth-id,redirectCode, alice@fintech, alice123@tpp, ConsentData] // But with the assumption that alice@fintech =/=> alice123@tpp. // Meaning that both identities are not yet verified equivalent (owned by the same natural person) Even though the ConsentAuthorizationSession in the TPP database is associated with two identities (alice@fintech and alice123@tpp), there is no proof what so ever that alice@fintech and alice123@tpp are controlled by the same natural person. The process continues with the addition of the psu-id@aspsp. In an Embedded-SCA case, the psu-id@aspsp is collected by the ConsentAuthorisationApi and forwarded to the OpenBankingApi of the ASPSP. In this case it is easy to assume uniqueness between both psu-id@tpp and psu-id@aspsp. This will result in the following record after a successful embedded consent authorization at the ConsentAuthorisationApi: [auth-id,redirectCode]=ConsentAuthorizationSession[auth-id,redirectCode, alice@fintech, alice123@tpp, alice-s@aspsp, ConsentData] // alice@fintech =/=> alice123@tpp. // Meaning that both identities are not yet verified equivalent (owned by the same natural person) // alice123@tpp ==> alice-s@aspsp. // Meaning alice123@tpp could provide the banking credentials of alice-s@aspsp. Even in this embedded case, there is still a missing equivalence between alice@fintech and alice-s@tpp. Step-3: Identify PSU at the ASPSP's OnlineBankingApi In a Redirect-SCA case (oauth, redirect, decoupled), the PSU will have to be redirected by the ConsentAuthorisationApi to the OnlienBanking interface of the ASPSP. After a successful consent authorization at the OnlienBanking interface, the record could be updated by the mean of poling the authorization status of this ConsentAuthorizationSession at the OpenBankingApi of the ASPSP. In this case the ConsentAuthorizationSession will look like: [auth-id,redirectCode]=ConsentAuthorizationSession[auth-id,redirectCode, alice@fintech, alice123@tpp, alice-s@aspsp, ConsentData] // alice@fintech =/=> alice123@tpp. // Meaning that both identities are not yet verified equivalent (owned by the same natural person) // alice123@tpp =/=> alice-s@aspsp. // Meaning that both identities are not yet verified equivalent (owned by the same natural person) Step-4: Verify Equivalence between psu-id@aspsp and psu-id@tpp After a successful consent authorization at the OnlineBankingApi of the ASPSP, the framework has to ensure equivalence between the PSU identified at the TPP and the PSU identified at the ASPSP. In this framework, we designed a two steps redirection FinTech -> TPP -> ASPSP knowing that this might make the process more cumbersome, but this design represents the superset of most of the cases found on the market. After thorough analysis of most scenarios, we noticed that the identity equivalence process can only securely happen in one of these ways: Step-4 Alt-1: Sharing of IDP (Identity Provider) If TPP and ASPSP can rely on the same IDP to identify the PSU, the identity association process will be simple as the IDP will provide a common identifier. For example the subject claim of an id-token leading to subject(alice123@tpp)==subject(alice-s@aspsp). Step-4 Alt-2: No Sharing of IDP (Identity Provider) If the TPP and ASPSP can not share the same identity provider, a back redirection from the ASPSP to the TPP must be used to help complete the identity verification. Note that the physical back redirection will not be possible in the decouple approach. Following sub-steps will be needed to ensure clean and secure back redirection: - A RedirectCookie must have been set on the PsuUserAgent while redirecting a user from the TPP (ConsentAuthorisationApi) to the ASPSP (OnlineBankingApi). - The url for the back redirection must have been protected against manipulation: - In case there is an initiation step present between TPP and ASPSP, use this step to transfer the back redirection url to the ASPSP (this is an example of the redirect approach of the NextGenPSD2 API). - In case there is no such initiation step (generally when OAuth is being used), make sure oAuth2 back redirection url templates and webOrigins are properly designed as the concrete back redirection url is transported with the consent request and exposed to attackers manipulations. - Design the back redirection url to contain a reference of the RedirectCookie (auth-id) and a corresponding XSRF-token (redirectState) for the validation of the RedirectCookie. A sample url can look like: /consent/{auth-id}/fromAspsp/{redirectState}/ok. See Redirection and Data Sharing for more detail. If a physical redirect can occur from the ASPSP (OnlineBankingApi) back to the TPP (ConsentAuthorisationApi), a validation of the original RedirectCookie can be taken as a guaranty to declare equivalence between the psu-id@tpp and the psu-id@aspsp . Step-4 Alt-3: No Sharing of IDP and Decoupled Approach For the decoupled approach, there is no way to provide a physical back redirect from the ASPSP to the TPP. So innovative data sharing methods are necessary to verify equivalence of both psu-id@tpp and psu-id@aspsp. This framework suggests the sharing of a QR-Code image as a mean of ensuring that the natural person in control of the ConsentAuthorisationApi is the same as the one in control of the OnlineBankingMobileApp used to execute the decoupled consent authorization against the OnlineBankingApi. - If the PSU is using a desktop to request the banking service, the decoupled consent authorization on the OnlineBankingMobileApp will starts by mean of the PSU scanning a QR-Code displayed on the user desktop by the ConsentAuthorisationUI. - If both ConsentAuthorisationUI and OnlineBankingMobileApp are running on the same user device, App to App physical redirection will be preferable. Turning this decoupled approach into a redirect approach. If App to App physical redirection is not possible, mobile device image sharing routines can be used to push the QR-Code produced by the ConsentAuthorisationApi to the decoupled OnlineBankingMobileApp. Step-5: Verify Equivalence between psu-id@tpp and psu-id@fintech We assume that there is a physical redirection possibility from the ConsentAuthorisationApi back to the FinTechApi. This assumption is based on the fact that there is a better synchronization between a TPP and FinTech using it's services. This is, the same principles described in \"Step-4 Alt-1\" and \"Step-4 Alt-2\" apply. Consent Authorization, Identity Equivalence and Service Execution In some OpenBanking approaches, validating the consent at the OnlineBanking interface of the ASPSP directly finalizes authorization of the service request. The NextGenPSD2 specification finalizes a payment initiation with the act of a PSU authorizing the payment consent (either on the ASPSP or TPP interface). But at this stage, the identity equivalence verification described above might not have happened yet leaving the process incomplete. This is a weakness in the process design as there can be no guaranty of a matching association between PSU identity of the TPP PSU and PSU identity of ASPSP before a final verification of the identity equivalence. In order to fix this problem, concerned OpenBankingApi (like the NextGenPSD2) will have to be modified to separate consent authorization from service request. - A consent authorization is always finalized with the verification of the identity equivalence (psu-id@fintech==> psu-id@tpp ==> psu-id@aspsp). - The FinTechApi will then re-send the service request to the TppBankingApi - TppBankingApi will only forward service request to ASPSP's OpenBankingApi if the corresponding consent is legitimate (meaning if identity equivalence verification was successful). Applications Running on a User Device FinTechUI UI Application running on the PsuUserAgent and used by the PSU to access the FinTechApi ConsentAuthorisationUI UI used by PSU to authorize consent in embedded case. OnlineBankingUI This UI manages the interaction between the PSU and the ASPSP in redirect cases. FinTech Data Center Data center environment of the FinTech. Host the FinTechApi. FinTechApi Financial web service provided by the FinTech. FinTechLoginSessionCookie This is a SessionCookie used to maintain the login session between the FinTechUI and the FinTechApi. As this maintains the login state of the PSU in the FinTechUI, this session can be kept open for the life span of the interaction between the FinTechUI and the FinTechApi. There is a X-XSRF-TOKEN String associated with the FinTechLoginSessionCookie. This information must be presented whenever the FinTechApi consumes the FinTechLoginSessionCookie. The X-XSRF-TOKEN encodes a key that is used to validate (evtl. encrypt/decrypt) information stored in the corresponding FinTechLoginSessionCookie. Tpp Data Center Data center environment of the TPP TPP A TPP is a Third Party Provider. TppBankingApi Tpp backend providing access to ASPSP banking functionality. This interface is not directly accessed by the PSU but by the FinTechApi. FinTechApi will use a FinTechContext to authenticate with the TppBankingApi. TppBankSearchApi Repository of banks maintained in the TPP's banking gateway. The banking search API will later present an interface to configure profiles attached to listed banks. BankDescriptor Descriptive information associated with a bank like: - The name of the Bank - The address of the bank - The bank identification code BankProfile BankingApi profile information associated with a bank like: - The BankingProtocol used to connect with the bank - List of Banking services provided by the BankingApi of the bank - SCA approaches associated with the BankingApi - ScaUIMetadaData: Screens and field used to collect user authentication data. - Actions to be performed by the PSU prior to using the BankingProtocol AisConsentSpec Specification associated with an AisConsent. This is highly dependent on the BankProfile. Following information might be carried by an AisConsentSpec object: - recurringIndicator - validUntil - frequencyPerDay - combinedService - accountAccessTemplate - availableAccounts[availableAccountsWithBalances, allAccounts] - allPsd2[allAccounts] ConsentData In the context of OpenBanking, a consent encompasses all information necessary to provide a third party with the authorization to access banking services on behalf of the PSU. These are: - PSU banking identifier information known as (psu-id@aspsp or psuId, psuCorporateId) - PSU account details information (like account numbers, iban, ...) - PSU payment orders (including beneficiary names, amounts, ...) - PSU authentication methods All these information are stored in different devices during the consent authorization session. Form of storages are among others: - Held in the browser page for display to the PSU - Stored in the Cookie for reuse by the corresponding backend - Stored in backend databases for transfer to other server components - Stored in backend databases for reuse by server components. For the purpose of protecting these data, framework is designed to always have consent data encrypted while at rest or on transit. General logic is that encrypted payload and encryption key do not reside in the same environment, unless needed for decryption and processing of those data. Following object hold consent data - TppConsentSession : Stores consent data in the database of the TPP. - RedirectSession : Temporary storage of consent data when PSU is being redirected between FinTech, TPP and ASPSP. - PsuConsentSession : This is only the reference to the TppConsentSession for a given FinTech. As the same TppConsentSession might be shared among many FinTechs. FinTechContext Information used to identify the FinTech application at the TppBankingApi. For example a FinTech SSL client certificate or an APIKey or an oAuth2 Password Grant Credential. FinTechContext might also contain FinTEch specific Information like: - Data needed to customize PSU access at the ConsentAuthorisationApi (showInfoFlag) - Data needed to manage redirection of PSU back from the ConsentAuthorizeApi to the FintechApi like (FinTech-Redirect-URI-Template, FinTech-Nok-Redirect-URI-Template, FinTech-Explicit-Authorisation-Preferred, FinTech-Content-Negotiation) ConsentAuthorisationApi Interface used by the PSU to authorize a consent. ConsentAuthSessionCookie This is a SessionCookie used to maintain the login session between the ConsentAuthorisationUI and the ConsentAuthorisationApi. As this maintains the login state of the PSU in the ConsentAuthorisationUI, this session can be kept open for the life span of the interaction between the ConsentAuthorisationUI and the ConsentAuthorisationApi. There is a X-XSRF-TOKEN String associated with the ConsentAuthSessionCookie. This information must be presented whenever the ConsentAuthorisationApi consumes the ConsentAuthSessionCookie. The X-XSRF-TOKEN encodes a key that is used to validate (evtl. encrypt/decrypt) information stored in the corresponding ConsentAuthSessionCookie. RedirectSession Holds consent information for the duration of a redirect. Redirect patterns are described below . RedirectSessionStoreApi Storage of temporary redirect sessions. Redirect session are stored only for the duration of the redirect request while redirecting from: * FinTechApi to ConsentAuthorisationApi and validate when redirected back to secure coherance between FinTech and TPP identities. * ConsentAuthorisationApi to the OnlineBankingApi and validate when redirected back to secure coherance between TPP and ASPSP identities. Consent Data might contain security sensitive data like account number or payment information of the PSU. This is the reason why they will be encrypted prior to being temporarily held for the duration of the redirection in the RedirectSessionStoreApi. So the RedirectSessionStoreApi will generate a temporary authorization code that contains both the id of the redirect session and the key used to encrypt the content of the redirect session. Upon request, the RedirectSessionStoreApi will use the provided redirectCode to read and decrypt the consent session and will delete the consent session prior to returning it for the first time to the caller. BankingProtocol Component managing access to a banking interfaces. We will have to deal with many protocols like NextGenPSD2, HBCI, OpenBanking UK, PolishAPI. For design details, see BankingProtocol Aspsp Data Center Data center environment of the ASPSP AspspBankingApi Api banking provided by ASPSP. This interface is not directly accessed by the PSU but by the TppBankingApi. TppBankingApi will use a TppContext to authenticate with the TppBankingApi. TppContext Information used to identify the Tpp application in the ASPSP environment. Like a TPP QWAC certificate. TppConsentSession Storage for consent data in the realm of the TPP accessible to both the TppBankingApi and the ConsentAuthorizationApi. The cryptographic key needed to recover the TppConsentSession is always delivered by the calling layer. These are: - FinTechUI -> FinTechApi -> TppBankingApi : in this case the key needed to recover the TppConsentSession in contained in the PsuConsentSession. Generally that key will transitively originate from an interaction with the user agent. - CosentAuthorizationUI -> CosentAuthorizationApi : in this case the key needed to recover the TppConsentSession originate from the ConsentAuthSessionCookie. Beside consent data, additional data might be held in the TppConsentSession: - FinTechContext : Data needed to authorize the FinTechApi (FinTechSSLCertificate, ApiKey, SignedJWT) - Additional information needed for interaction between TPP and ASPSP but without any concern to the PSU. OnlineBankingApi Generally the online banking application on an ASPSP. In redirect cases, the ASPSP OnlineBankingApi establishes a direct session with the PSU to allow the PSU to identify himself, review and authorize the consent.","title":"Dictionary"},{"location":"architecture/dictionary/#dictionary","text":"AisConsentSpec App AspspBankingApi BankDescriptor BankingProtocol BankProfile Center Center ConsentAuthorisationApi ConsentAuthorisationUI ConsentAuthSessionCookie consentAuthState ConsentData Considerations Dictionary Fintech2TppRedirectInfoPage FinTechApi FinTechContext FinTechDC FinTechLoginSessionCookie FinTechLoginSessionState FinTechUI Information OnlineBanking2ConsentAuthRedirectInfoPage OnlineBankingApi OnlineBankingConsentSessionCookie OnlineBankingLoginSessionCookie OnlineBankingUI PSU PsuConsentSession PsuIdentifier PsuUserAgent PsuUserDevice Redirection RedirectSessionStoreApi RedirectSession Sharing TppBankingApi TppBankSearchApi TppConsentSession TppContext TPP UserAgentContext WebBrowser","title":"Dictionary"},{"location":"architecture/dictionary/#properties-of-a-psu","text":"A PSU is a natural person A PSU is in possession of some personal non sharable online banking credentials A PSU uses applications running on some devices to interact with online services","title":"Properties of a PSU"},{"location":"architecture/dictionary/#psu-idfintech","text":"This is the identity of the PSU in the realm of the FinTech, as most FinTech application require the PSU to establish an identity before using the application. This is the most important identity as it covers the consumption of the core services. Further identities (tpp, aspsp) are only needed for authorization. This framework is designed such as to request the FinTech to provide a permanent unique identity of each PSU to the TPP. This is what we call the psu-id@fintech","title":"psu-id@fintech"},{"location":"architecture/dictionary/#psu-idtpp","text":"This is the PSU as known to the TPP. If TPP environment is designed to service a single FinTech, this identity can be set equal to the psu-id@fintech . If a TPPenvironment services multiple FinTech entities, the TPP will have to establish a separated PSU identity that references all corresponding FinTech identities. This requirement only exists because some OpenBanking specifications do not allow TPP to maintain multiple valid consents of the same type on the same bank account. In a situation where the TPP uses the same account information consent to service many FinTech, a TPP consent management layer must allow a PSU to revoke that consent for a designated FinTech without revoking the consent at the ASPSP level.","title":"psu-id@tpp"},{"location":"architecture/dictionary/#psu-idaspsp","text":"This is the identity of the PSU as known to the ASPSP. This identity generally matches an online banking identifier in the realm of the ASPSP.","title":"psu-id@aspsp"},{"location":"architecture/dictionary/#webbrowser-based-useragent","text":"A WebBrowser is considered compliant in the context of this framework when it can protect specific information used between the PsuUserDevice and the the corresponding server application to track the user session. For session tracking, this framework uses Cookies RFC6265 .","title":"WebBrowser based UserAgent"},{"location":"architecture/dictionary/#native-applications","text":"The UserAgent might be a native application running on a user mobile device or a desktop computer. In this case, redirection might still take place, but with consideration of the physical transition between source and target UI-Application. Following specifications deal with security threads associated with the redirection between UI-Application on a user device: RFC8252:OAuth 2.0 for Native Apps , RFC7636:Proof Key for Code Exchange by OAuth Public Clients . For the purpose of keeping the overall architecture of this framework simple, we require native applications to provide the same behavior as the Web Browser based user agents described above.","title":"Native Applications"},{"location":"architecture/dictionary/#security-considerations","text":"","title":"Security Considerations"},{"location":"architecture/dictionary/#step-1-identify-psu-at-the-fintechapi","text":"We always expect the PSU to be identified at the FinTechApi interface. So we assume that the psu-id@fintech is known. The integrity of the rest of the framework relys on the capability of the FinTech to protect the session associating the PSU to the FinTechApi. The service request itself is always initiated by the FinTechApi. Before initiation, we assume that the PSU (alice) has signed into the FinTechApi and her identity is known to the FinTechApi and thus associated with the service request forwarded to the TppBankingApi.","title":"Step-1: Identify PSU at the FinTechApi"},{"location":"architecture/dictionary/#step-2-store-psu-idfintech-with-the-consentauthorizationsession","text":"While processing a service request, if the TppBankingApi notices that the service request is not covered by a consent (either as a result of pre-checking the consent or from an error returned by the OpenBankingApi), the TppBankingApi will trigger a new ConsentAuthorizationSession. Starting a new ConsentAuthorizationSession, we require the TppBankingApi to store the identity of service requesting PSU alice@fintech with the ConsentAuthorizationSession record before initiating a redirect to the ConsentAuthorisationApi. This is, the ConsentAuthorizationSession record stored in the TPP Database will have the form [auth-id,redirectCode]=ConsentAuthorizationSession[auth-id,redirectCode, alice@fintech, ConsentData] // Where redirectCode is a one time key. // Where auth-id is the identifier of this ConsentAuthorizationSession where the redirectCode can be used by the ConsentAuthorisationApi once to retrieve the ConsentAuthorizationSession.","title":"Step-2: Store psu-id@fintech with the ConsentAuthorizationSession"},{"location":"architecture/dictionary/#step-2-identify-psu-at-the-tpp-consentauthorisationapi","text":"At first, redirecting a PSU from the FinTechApi to the TPP ConsentAuthorisationApi does not establish any relationship between the PSU and the TPP, even if we can use the redirectCode associated with the redirected url to retrieve ConsentAuthorisationSession. Off course the ConsentAuthorisationApi knows that the ConsentAuthorizationSession was initiated by alice@fintech, but this does not mean that the PSU controlling the current UserAgent (known as ConsentAuthorisationUI) is the same natural person as alice@fintech. In order to proceed with the ConsentAuthorisationSession, the TPP ConsentAuthorisationApi will have to establish an identification of the natural person controlling the UserAgent(implicit or explicit), resulting in a new PSU identity called (psu-id@tpp). This PSU identity (psu-id@tpp) will also be associated with the ConsentAuthorisationSession. At this stage, the ConsentAuthorizationSession record stored in the TPP Database will have the form: [auth-id,redirectCode]=ConsentAuthorizationSession[auth-id,redirectCode, alice@fintech, alice123@tpp, ConsentData] // But with the assumption that alice@fintech =/=> alice123@tpp. // Meaning that both identities are not yet verified equivalent (owned by the same natural person) Even though the ConsentAuthorizationSession in the TPP database is associated with two identities (alice@fintech and alice123@tpp), there is no proof what so ever that alice@fintech and alice123@tpp are controlled by the same natural person. The process continues with the addition of the psu-id@aspsp. In an Embedded-SCA case, the psu-id@aspsp is collected by the ConsentAuthorisationApi and forwarded to the OpenBankingApi of the ASPSP. In this case it is easy to assume uniqueness between both psu-id@tpp and psu-id@aspsp. This will result in the following record after a successful embedded consent authorization at the ConsentAuthorisationApi: [auth-id,redirectCode]=ConsentAuthorizationSession[auth-id,redirectCode, alice@fintech, alice123@tpp, alice-s@aspsp, ConsentData] // alice@fintech =/=> alice123@tpp. // Meaning that both identities are not yet verified equivalent (owned by the same natural person) // alice123@tpp ==> alice-s@aspsp. // Meaning alice123@tpp could provide the banking credentials of alice-s@aspsp. Even in this embedded case, there is still a missing equivalence between alice@fintech and alice-s@tpp.","title":"Step-2: Identify PSU at the TPP ConsentAuthorisationApi"},{"location":"architecture/dictionary/#step-3-identify-psu-at-the-aspsps-onlinebankingapi","text":"In a Redirect-SCA case (oauth, redirect, decoupled), the PSU will have to be redirected by the ConsentAuthorisationApi to the OnlienBanking interface of the ASPSP. After a successful consent authorization at the OnlienBanking interface, the record could be updated by the mean of poling the authorization status of this ConsentAuthorizationSession at the OpenBankingApi of the ASPSP. In this case the ConsentAuthorizationSession will look like: [auth-id,redirectCode]=ConsentAuthorizationSession[auth-id,redirectCode, alice@fintech, alice123@tpp, alice-s@aspsp, ConsentData] // alice@fintech =/=> alice123@tpp. // Meaning that both identities are not yet verified equivalent (owned by the same natural person) // alice123@tpp =/=> alice-s@aspsp. // Meaning that both identities are not yet verified equivalent (owned by the same natural person)","title":"Step-3: Identify PSU at the ASPSP's OnlineBankingApi"},{"location":"architecture/dictionary/#step-4-verify-equivalence-between-psu-idaspsp-and-psu-idtpp","text":"After a successful consent authorization at the OnlineBankingApi of the ASPSP, the framework has to ensure equivalence between the PSU identified at the TPP and the PSU identified at the ASPSP. In this framework, we designed a two steps redirection FinTech -> TPP -> ASPSP knowing that this might make the process more cumbersome, but this design represents the superset of most of the cases found on the market. After thorough analysis of most scenarios, we noticed that the identity equivalence process can only securely happen in one of these ways:","title":"Step-4: Verify Equivalence between psu-id@aspsp and psu-id@tpp"},{"location":"architecture/dictionary/#step-4-alt-1-sharing-of-idp-identity-provider","text":"If TPP and ASPSP can rely on the same IDP to identify the PSU, the identity association process will be simple as the IDP will provide a common identifier. For example the subject claim of an id-token leading to subject(alice123@tpp)==subject(alice-s@aspsp).","title":"Step-4 Alt-1: Sharing of IDP (Identity Provider)"},{"location":"architecture/dictionary/#step-4-alt-2-no-sharing-of-idp-identity-provider","text":"If the TPP and ASPSP can not share the same identity provider, a back redirection from the ASPSP to the TPP must be used to help complete the identity verification. Note that the physical back redirection will not be possible in the decouple approach. Following sub-steps will be needed to ensure clean and secure back redirection: - A RedirectCookie must have been set on the PsuUserAgent while redirecting a user from the TPP (ConsentAuthorisationApi) to the ASPSP (OnlineBankingApi). - The url for the back redirection must have been protected against manipulation: - In case there is an initiation step present between TPP and ASPSP, use this step to transfer the back redirection url to the ASPSP (this is an example of the redirect approach of the NextGenPSD2 API). - In case there is no such initiation step (generally when OAuth is being used), make sure oAuth2 back redirection url templates and webOrigins are properly designed as the concrete back redirection url is transported with the consent request and exposed to attackers manipulations. - Design the back redirection url to contain a reference of the RedirectCookie (auth-id) and a corresponding XSRF-token (redirectState) for the validation of the RedirectCookie. A sample url can look like: /consent/{auth-id}/fromAspsp/{redirectState}/ok. See Redirection and Data Sharing for more detail. If a physical redirect can occur from the ASPSP (OnlineBankingApi) back to the TPP (ConsentAuthorisationApi), a validation of the original RedirectCookie can be taken as a guaranty to declare equivalence between the psu-id@tpp and the psu-id@aspsp .","title":"Step-4 Alt-2: No Sharing of IDP (Identity Provider)"},{"location":"architecture/dictionary/#step-4-alt-3-no-sharing-of-idp-and-decoupled-approach","text":"For the decoupled approach, there is no way to provide a physical back redirect from the ASPSP to the TPP. So innovative data sharing methods are necessary to verify equivalence of both psu-id@tpp and psu-id@aspsp. This framework suggests the sharing of a QR-Code image as a mean of ensuring that the natural person in control of the ConsentAuthorisationApi is the same as the one in control of the OnlineBankingMobileApp used to execute the decoupled consent authorization against the OnlineBankingApi. - If the PSU is using a desktop to request the banking service, the decoupled consent authorization on the OnlineBankingMobileApp will starts by mean of the PSU scanning a QR-Code displayed on the user desktop by the ConsentAuthorisationUI. - If both ConsentAuthorisationUI and OnlineBankingMobileApp are running on the same user device, App to App physical redirection will be preferable. Turning this decoupled approach into a redirect approach. If App to App physical redirection is not possible, mobile device image sharing routines can be used to push the QR-Code produced by the ConsentAuthorisationApi to the decoupled OnlineBankingMobileApp.","title":"Step-4 Alt-3: No Sharing of IDP and Decoupled Approach"},{"location":"architecture/dictionary/#step-5-verify-equivalence-between-psu-idtpp-and-psu-idfintech","text":"We assume that there is a physical redirection possibility from the ConsentAuthorisationApi back to the FinTechApi. This assumption is based on the fact that there is a better synchronization between a TPP and FinTech using it's services. This is, the same principles described in \"Step-4 Alt-1\" and \"Step-4 Alt-2\" apply.","title":"Step-5: Verify Equivalence between psu-id@tpp and psu-id@fintech"},{"location":"architecture/dictionary/#consent-authorization-identity-equivalence-and-service-execution","text":"In some OpenBanking approaches, validating the consent at the OnlineBanking interface of the ASPSP directly finalizes authorization of the service request. The NextGenPSD2 specification finalizes a payment initiation with the act of a PSU authorizing the payment consent (either on the ASPSP or TPP interface). But at this stage, the identity equivalence verification described above might not have happened yet leaving the process incomplete. This is a weakness in the process design as there can be no guaranty of a matching association between PSU identity of the TPP PSU and PSU identity of ASPSP before a final verification of the identity equivalence. In order to fix this problem, concerned OpenBankingApi (like the NextGenPSD2) will have to be modified to separate consent authorization from service request. - A consent authorization is always finalized with the verification of the identity equivalence (psu-id@fintech==> psu-id@tpp ==> psu-id@aspsp). - The FinTechApi will then re-send the service request to the TppBankingApi - TppBankingApi will only forward service request to ASPSP's OpenBankingApi if the corresponding consent is legitimate (meaning if identity equivalence verification was successful).","title":"Consent Authorization, Identity Equivalence and Service Execution"},{"location":"architecture/dictionary/#applications-running-on-a-user-device","text":"","title":"Applications Running on a User Device"},{"location":"architecture/uses_cases/","text":"Use Cases Login with FinTech Application Search Bank Select Bank List of Transactions Redirect to Consent Authorization API Authorize Consent Redirect Approach Authorize Consent Embedded Approach Consume Service","title":"Use Cases"},{"location":"architecture/uses_cases/#use-cases","text":"Login with FinTech Application Search Bank Select Bank List of Transactions Redirect to Consent Authorization API Authorize Consent Redirect Approach Authorize Consent Embedded Approach Consume Service","title":"Use Cases"},{"location":"architecture/drafts/initial_requirements/","text":"Tech setup Spring Boot >= 2.2 Flowable BPMN 6.x Drools rule engine (embedded with Flowable) Postgres RDBMS 12.x XS2A-flow for tests Least annoying API: TPP creates user profile (name, surname,...) that provides information necessary to perform requests on his behalf TPP provides setting which mode will be used STATIC or DIALOG to perform user requests In STATIC mode TPP must fulfill all fields that are not provided by profile but are necessary to perform action (except SCA) TPP calls i.e. /pay/IBAN-from/IBAN-to/CURRENCY/amount with parameters from step nr. 3. The only extra stuff to complete the call is SCA Initial implementation diagram E2E flows Transaction list flow. Performing payment flow. Generic request handling (Check consent is valid pre-filter) Initially (for MVP0), questions Needs consent? and Consent valid? are answered using database-table that contains bank profile, in future it can be switched to rule engine or entire BPMN job. TPP can initiate consent with PSU under the hood if required. This basically means that if request is missing consent, but has flag to allow automatic consent creation TPP will call obtaining consent flow. Obtaining AIS Consent swimlane Getting transaction list using AIS Consent swimlane Full swimlane e2e for getting transaction list Get transaction list by FinTech **Notes:** 1. Initially PSU enters FinTech screen 'Transaction list' 1. Since consent is missing, when being asked for 'Transaction list' TPP will create implicit consent with PSU (since PSU is in session with FinTech) 1. After consent was established FinTech can store it and get 'Transaction list' without PSU intervention 1. If consent has expired FinTech should inform user and perform step 1 again ![Implementation draft diagram - Tx list full](http://www.plantuml.com/plantuml/proxy?src=https://raw.githubusercontent.com/adorsys/open-banking-gateway/develop/docs/architecture/drafts/implementation-v0-full-flow-tx-list.puml&fmt=svg&vvv=1&sanitize=true) Full swimlane e2e for performing payment Perform payment by FinTech ![Implementation draft diagram - Perform payment](http://www.plantuml.com/plantuml/proxy?src=https://raw.githubusercontent.com/adorsys/open-banking-gateway/develop/docs/architecture/drafts/implementation-v0-full-flow-payment.puml&fmt=svg&vvv=2&sanitize=true) API OpenBankingGateway Api is defined for boundary (of course TPP itself can use it): FinTech with OpenBankingGw API <--> TPP with OpenBankingGw Impl (See diagrams above) Consent API: 1. PUT /consents/{bankId} body: {accounts: [<accountIds>], allAccounts: true} to create consent Account information API: 1. GET /transactions to read transactions with option to ask for consent automatically 1. GET /accounts to read account details with option to ask for consent automatically Payment API: 1. PUT /payments to initiate payment ... In short With details API sketch PSU wants to pay 100EUR to IBAN 12345 Generic case Find PSU client bank id GET /api/v1/banks?name=Deutsche or GET /api/v1/banks?bic=12345 -> {bankId} View necessary parameters that are required from PSU for {bankId} to execute payment: GET /api/v1/payments/{bankId}/{psuId}/{ibanFrom}/{ibanTo}/parameters - yields {\"GEO_LOCATION\": \"This payment requires client geo-location\"} (Note: this also may yield i.e. SCA method if PSU did not select it in profile) Since request can't automatically proceed, TPP reads required GEO_LOCATION from PSU Now TPP can proceed with payment PUT /api/v1/payments/{bankId}/{psuId}/{ibanFrom}/{ibanTo} body: {\"amount\": 100.0, \"currency\": \"EUR\", \"GEO_LOCATION\": {\"lat\": 12, \"lng\": 10.0}} (Note: This can have i.e. SCA method to use that overrides profile defaults) OpenBanking handles request sequence using computed process Sequence diagram TPP acquires mandatory parameters before request TPP acquires mandatory parameters during request","title":"Draft"},{"location":"architecture/drafts/initial_requirements/#tech-setup","text":"Spring Boot >= 2.2 Flowable BPMN 6.x Drools rule engine (embedded with Flowable) Postgres RDBMS 12.x XS2A-flow for tests","title":"Tech setup"},{"location":"architecture/drafts/initial_requirements/#least-annoying-api","text":"TPP creates user profile (name, surname,...) that provides information necessary to perform requests on his behalf TPP provides setting which mode will be used STATIC or DIALOG to perform user requests In STATIC mode TPP must fulfill all fields that are not provided by profile but are necessary to perform action (except SCA) TPP calls i.e. /pay/IBAN-from/IBAN-to/CURRENCY/amount with parameters from step nr. 3. The only extra stuff to complete the call is SCA","title":"Least annoying API:"},{"location":"architecture/drafts/initial_requirements/#initial-implementation-diagram","text":"","title":"Initial implementation diagram"},{"location":"architecture/drafts/initial_requirements/#e2e-flows","text":"Transaction list flow. Performing payment flow.","title":"E2E flows"},{"location":"architecture/drafts/initial_requirements/#generic-request-handling-check-consent-is-valid-pre-filter","text":"Initially (for MVP0), questions Needs consent? and Consent valid? are answered using database-table that contains bank profile, in future it can be switched to rule engine or entire BPMN job.","title":"Generic request handling (Check consent is valid pre-filter)"},{"location":"architecture/drafts/initial_requirements/#tpp-can-initiate-consent-with-psu-under-the-hood-if-required","text":"This basically means that if request is missing consent, but has flag to allow automatic consent creation TPP will call obtaining consent flow.","title":"TPP can initiate consent with PSU under the hood if required."},{"location":"architecture/drafts/initial_requirements/#obtaining-ais-consent-swimlane","text":"","title":"Obtaining AIS Consent swimlane"},{"location":"architecture/drafts/initial_requirements/#getting-transaction-list-using-ais-consent-swimlane","text":"","title":"Getting transaction list using AIS Consent swimlane"},{"location":"architecture/drafts/initial_requirements/#full-swimlane-e2e-for-getting-transaction-list","text":"Get transaction list by FinTech **Notes:** 1. Initially PSU enters FinTech screen 'Transaction list' 1. Since consent is missing, when being asked for 'Transaction list' TPP will create implicit consent with PSU (since PSU is in session with FinTech) 1. After consent was established FinTech can store it and get 'Transaction list' without PSU intervention 1. If consent has expired FinTech should inform user and perform step 1 again ![Implementation draft diagram - Tx list full](http://www.plantuml.com/plantuml/proxy?src=https://raw.githubusercontent.com/adorsys/open-banking-gateway/develop/docs/architecture/drafts/implementation-v0-full-flow-tx-list.puml&fmt=svg&vvv=1&sanitize=true)","title":"Full swimlane e2e for getting transaction list"},{"location":"architecture/drafts/initial_requirements/#full-swimlane-e2e-for-performing-payment","text":"Perform payment by FinTech ![Implementation draft diagram - Perform payment](http://www.plantuml.com/plantuml/proxy?src=https://raw.githubusercontent.com/adorsys/open-banking-gateway/develop/docs/architecture/drafts/implementation-v0-full-flow-payment.puml&fmt=svg&vvv=2&sanitize=true)","title":"Full swimlane e2e for performing payment"},{"location":"architecture/drafts/initial_requirements/#api","text":"OpenBankingGateway Api is defined for boundary (of course TPP itself can use it): FinTech with OpenBankingGw API <--> TPP with OpenBankingGw Impl (See diagrams above) Consent API: 1. PUT /consents/{bankId} body: {accounts: [<accountIds>], allAccounts: true} to create consent Account information API: 1. GET /transactions to read transactions with option to ask for consent automatically 1. GET /accounts to read account details with option to ask for consent automatically Payment API: 1. PUT /payments to initiate payment ...","title":"API"},{"location":"architecture/drafts/initial_requirements/#in-short","text":"","title":"In short"},{"location":"architecture/drafts/initial_requirements/#with-details","text":"","title":"With details"},{"location":"architecture/drafts/initial_requirements/#api-sketch","text":"","title":"API sketch"},{"location":"architecture/drafts/initial_requirements/#psu-wants-to-pay-100eur-to-iban-12345","text":"","title":"PSU wants to pay 100EUR to IBAN 12345"},{"location":"architecture/drafts/initial_requirements/#generic-case","text":"Find PSU client bank id GET /api/v1/banks?name=Deutsche or GET /api/v1/banks?bic=12345 -> {bankId} View necessary parameters that are required from PSU for {bankId} to execute payment: GET /api/v1/payments/{bankId}/{psuId}/{ibanFrom}/{ibanTo}/parameters - yields {\"GEO_LOCATION\": \"This payment requires client geo-location\"} (Note: this also may yield i.e. SCA method if PSU did not select it in profile) Since request can't automatically proceed, TPP reads required GEO_LOCATION from PSU Now TPP can proceed with payment PUT /api/v1/payments/{bankId}/{psuId}/{ibanFrom}/{ibanTo} body: {\"amount\": 100.0, \"currency\": \"EUR\", \"GEO_LOCATION\": {\"lat\": 12, \"lng\": 10.0}} (Note: This can have i.e. SCA method to use that overrides profile defaults) OpenBanking handles request sequence using computed process","title":"Generic case"},{"location":"architecture/drafts/initial_requirements/#sequence-diagram","text":"","title":"Sequence diagram"},{"location":"architecture/drafts/initial_requirements/#tpp-acquires-mandatory-parameters-before-request","text":"","title":"TPP acquires mandatory parameters before request"},{"location":"architecture/drafts/initial_requirements/#tpp-acquires-mandatory-parameters-during-request","text":"","title":"TPP acquires mandatory parameters during request"}]}